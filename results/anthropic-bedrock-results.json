[
  {
    "test_name": "Bug Detection",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Analyse this TypeScript code and identify all bugs. List each bug with line number and explanation:\n\n```typescript\n// A calculator with intentional bugs for testing\nexport class Calculator {\n  private result: number = 0;\n\n  add(a: number, b: number): number {\n    // Bug: should be a + b\n    return a - b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n\n  multiply(a: number, b: number): number {\n    // Bug: integer division instead of multiplication\n    return Math.floor(a / b);\n  }\n\n  divide(a: number, b: number): number {\n    // Bug: no zero division check\n    return a / b;\n  }\n\n  // Missing: power function\n  // Missing: square root function\n\n  getResult(): number {\n    return this.result;\n  }\n}\n\n// Test cases (some will fail due to bugs)\nconst calc = new Calculator();\nconsole.log(\"5 + 3 =\", calc.add(5, 3));        // Should be 8, returns 2\nconsole.log(\"10 - 4 =\", calc.subtract(10, 4)); // Should be 6, returns 6\nconsole.log(\"6 * 7 =\", calc.multiply(6, 7));   // Should be 42, returns 0\nconsole.log(\"20 / 4 =\", calc.divide(20, 4));   // Should be 5, returns 5\n\n```",
    "response": "## Bug Analysis\n\n### Bug 1: Line 7 - Incorrect `add` implementation\n**Issue:** Uses subtraction (`-`) instead of addition (`+`)\n```typescript\nreturn a - b;  // Should be: return a + b;\n```\n**Impact:** `add(5, 3)` returns `2` instead of `8`\n\n---\n\n### Bug 2: Line 16 - Incorrect `multiply` implementation\n**Issue:** Uses floor division instead of multiplication\n```typescript\nreturn Math.floor(a / b);  // Should be: return a * b;\n```\n**Impact:** `multiply(6, 7)` returns `0` instead of `42`\n\n---\n\n### Bug 3: Line 21 - Missing zero division check in `divide`\n**Issue:** No validation for `b === 0`, will return `Infinity` or `NaN`\n```typescript\n// Should add:\nif (b === 0) {\n  throw new Error(\"Cannot divide by zero\");\n}\n```\n**Impact:** `divide(5, 0)` returns `Infinity` instead of throwing an error\n\n---\n\n### Bug 4: Lines 4, 27-29 - Unused `result` property\n**Issue:** `this.result` is initialized but never updated by any operation. `getResult()` always returns `0`.\n**Impact:** The stored result feature is non-functional\n\n---\n\n## Summary Table\n\n| Line | Method | Bug Type | Expected | Actual |\n|------|--------|----------|----------|--------|\n| 7 | `add` | Wrong operator | `a + b` | `a - b` |\n| 16 | `multiply` | Wrong operation | `a * b` | `Math.floor(a/b)` |\n| 21 | `divide` | Missing validation | Error on zero | `Infinity` |\n| 4, 27-29 | `result` | Dead code | Updated result | Always 0 |",
    "tokens_in": 379,
    "tokens_out": 457,
    "cost": 0.03996,
    "duration_ms": 8165,
    "success": true,
    "error": null
  },
  {
    "test_name": "Code Refactoring",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Refactor this TypeScript code to fix the issues listed in the comments. Provide the improved code:\n\n```typescript\n// Simple Express-like API endpoint that needs refactoring\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  createdAt: string;\n}\n\n// Global state (bad practice)\nlet users: User[] = [];\nlet nextId = 1;\n\n// Load users from file\nfunction loadUsers() {\n  if (existsSync('users.json')) {\n    const data = readFileSync('users.json', 'utf-8');\n    users = JSON.parse(data);\n    nextId = Math.max(...users.map(u => u.id), 0) + 1;\n  }\n}\n\n// Save users to file\nfunction saveUsers() {\n  writeFileSync('users.json', JSON.stringify(users));\n}\n\n// API handlers (no validation, no error handling)\nexport function createUser(name: string, email: string) {\n  const user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  users.push(user);\n  saveUsers();\n  return user;\n}\n\nexport function getUser(id: number) {\n  return users.find(u => u.id === id);\n}\n\nexport function updateUser(id: number, name: string, email: string) {\n  const user = users.find(u => u.id === id);\n  if (user) {\n    user.name = name;\n    user.email = email;\n    saveUsers();\n  }\n  return user;\n}\n\nexport function deleteUser(id: number) {\n  const index = users.findIndex(u => u.id === id);\n  if (index >= 0) {\n    users.splice(index, 1);\n    saveUsers();\n  }\n}\n\nexport function listUsers() {\n  return users;\n}\n\n// Issues to fix:\n// 1. No input validation\n// 2. No error handling\n// 3. Global mutable state\n// 4. Synchronous file operations\n// 5. No TypeScript strict mode usage\n// 6. No email format validation\n// 7. No duplicate email check\n\n```",
    "response": "```typescript\nimport { readFile, writeFile, access } from 'fs/promises';\nimport { constants } from 'fs';\n\ninterface User {\n  readonly id: number;\n  readonly name: string;\n  readonly email: string;\n  readonly createdAt: string;\n}\n\ninterface CreateUserInput {\n  name: string;\n  email: string;\n}\n\ninterface UpdateUserInput {\n  name?: string;\n  email?: string;\n}\n\ntype Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };\n\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NotFoundError';\n  }\n}\n\nclass DuplicateError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DuplicateError';\n  }\n}\n\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nfunction validateEmail(email: string): boolean {\n  return EMAIL_REGEX.test(email);\n}\n\nfunction validateName(name: string): boolean {\n  return name.trim().length >= 1 && name.trim().length <= 100;\n}\n\nexport class UserRepository {\n  private users: User[] = [];\n  private nextId = 1;\n  private readonly filePath: string;\n\n  constructor(filePath: string = 'users.json') {\n    this.filePath = filePath;\n  }\n\n  async initialize(): Promise<Result<void>> {\n    try {\n      await access(this.filePath, constants.F_OK);\n      const data = await readFile(this.filePath, 'utf-8');\n      const parsed = JSON.parse(data) as User[];\n      this.users = parsed;\n      this.nextId = parsed.length > 0 \n        ? Math.max(...parsed.map(u => u.id)) + 1 \n        : 1;\n      return { success: true, data: undefined };\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        this.users = [];\n        this.nextId = 1;\n        return { success: true, data: undefined };\n      }\n      return { success: false, error: error as Error };\n    }\n  }\n\n  private async persist(): Promise<Result<void>> {\n    try {\n      await writeFile(this.filePath, JSON.stringify(this.users, null, 2));\n      return { success: true, data: undefined };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  private findByEmail(email: string): User | undefined {\n    return this.users.find(u => u.email.toLowerCase() === email.toLowerCase());\n  }\n\n  async createUser(input: CreateUserInput): Promise<Result<User, ValidationError | DuplicateError | Error>> {\n    const { name, email } = input;\n\n    if (!validateName(name)) {\n      return { success: false, error: new ValidationError('Name must be between 1 and 100 characters') };\n    }\n\n    if (!validateEmail(email)) {\n      return { success: false, error: new ValidationError('Invalid email format') };\n    }\n\n    if (this.findByEmail(email)) {\n      return { success: false, error: new DuplicateError('Email already exists') };\n    }\n\n    const user: User = {\n      id: this.nextId++,\n      name: name.trim(),\n      email: email.toLowerCase().trim(),\n      createdAt: new Date().toISOString()\n    };\n\n    this.users.push(user);\n    const saveResult = await this.persist();\n    \n    if (!saveResult.success) {\n      this.users.pop();\n      this.nextId--;\n      return saveResult;\n    }\n\n    return { success: true, data: user };\n  }\n\n  getUser(id: number): Result<User, NotFoundError> {\n    const user = this.users.find(u => u.id === id);\n    if (!user) {\n      return { success: false, error: new NotFoundError(`User with id ${id} not found`) };\n    }\n    return { success: true, data: user };\n  }\n\n  async updateUser(id: number, input: UpdateUserInput): Promise<Result<User, ValidationError | NotFoundError | DuplicateError | Error>> {\n    const index = this.users.findIndex(u => u.id === id);\n    if (index === -1) {\n      return { success: false, error: new NotFoundError(`User with id ${id} not found`) };\n    }\n\n    const currentUser = this.users[index];\n    const { name, email } = input;\n\n    if (name !== undefined && !validateName(name)) {\n      return { success: false, error: new ValidationError('Name must be between 1 and 100 characters') };\n    }\n\n    if (email !== undefined) {\n      if (!validateEmail(email)) {\n        return { success: false, error: new ValidationError('Invalid email format') };\n      }\n      const existing = this.findByEmail(email);\n      if (existing && existing.id !== id) {\n        return { success: false, error: new DuplicateError('Email already exists') };\n      }\n    }\n\n    const updatedUser: User = {\n      ...currentUser,\n      name: name !== undefined ? name.trim() : currentUser.name,\n      email: email !== undefined ? email.toLowerCase().trim() : currentUser.email\n    };\n\n    const originalUser = this.users[index];\n    this.users[index] = updatedUser;\n    \n    const saveResult = await this.persist();\n    if (!saveResult.success) {\n      this.users[index] = originalUser;\n      return saveResult;\n    }\n\n    return { success: true, data: updatedUser };\n  }\n\n  async deleteUser(id: number): Promise<Result<void, NotFoundError | Error>> {\n    const index = this.users.findIndex(u => u.id === id);\n    if (index === -1) {\n      return { success: false, error: new NotFoundError(`User with id ${id} not found`) };\n    }\n\n    const removedUser = this.users.splice(index, 1)[0];\n    const saveResult = await this.persist();\n    \n    if (!saveResult.success) {\n      this.users.splice(index, 0, removedUser);\n      return saveResult;\n    }\n\n    return { success: true, data: undefined };\n  }\n\n  listUsers(): readonly User[] {\n    return [...this.users];\n  }\n}\n```",
    "tokens_in": 587,
    "tokens_out": 1698,
    "cost": 0.13615500000000003,
    "duration_ms": 14380,
    "success": true,
    "error": null
  },
  {
    "test_name": "Algorithm Implementation",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Implement a TypeScript function that finds the longest palindromic substring in a string. Include:\n1. The implementation using dynamic programming\n2. Time and space complexity analysis\n3. Example usage with test cases",
    "response": "# Longest Palindromic Substring in TypeScript\n\nHere's a comprehensive implementation using dynamic programming with detailed analysis and test cases.\n\n```typescript\n/**\n * Finds the longest palindromic substring using Dynamic Programming\n * \n * DP Approach:\n * - dp[i][j] = true if substring s[i...j] is a palindrome\n * - Base cases: \n *   - Single characters are palindromes: dp[i][i] = true\n *   - Two consecutive same characters: dp[i][i+1] = true if s[i] === s[i+1]\n * - Transition: dp[i][j] = dp[i+1][j-1] && s[i] === s[j]\n */\nfunction longestPalindromicSubstring(s: string): string {\n    const n = s.length;\n    \n    // Edge cases\n    if (n === 0) return \"\";\n    if (n === 1) return s;\n    \n    // DP table: dp[i][j] indicates if s[i...j] is a palindrome\n    const dp: boolean[][] = Array.from({ length: n }, () => \n        Array(n).fill(false)\n    );\n    \n    let start = 0;      // Starting index of longest palindrome\n    let maxLength = 1;  // Length of longest palindrome found\n    \n    // Base case 1: All single characters are palindromes\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = true;\n    }\n    \n    // Base case 2: Check for palindromes of length 2\n    for (let i = 0; i < n - 1; i++) {\n        if (s[i] === s[i + 1]) {\n            dp[i][i + 1] = true;\n            start = i;\n            maxLength = 2;\n        }\n    }\n    \n    // Check for palindromes of length 3 and greater\n    // len is the length of substring being checked\n    for (let len = 3; len <= n; len++) {\n        // i is the starting index\n        for (let i = 0; i <= n - len; i++) {\n            // j is the ending index\n            const j = i + len - 1;\n            \n            // Check if s[i...j] is palindrome:\n            // - Characters at both ends must match\n            // - Inner substring must be palindrome\n            if (s[i] === s[j] && dp[i + 1][j - 1]) {\n                dp[i][j] = true;\n                \n                if (len > maxLength) {\n                    start = i;\n                    maxLength = len;\n                }\n            }\n        }\n    }\n    \n    return s.substring(start, start + maxLength);\n}\n\n/**\n * Alternative: Expand Around Center approach\n * Time: O(n\u00b2), Space: O(1)\n */\nfunction longestPalindromicSubstringOptimized(s: string): string {\n    if (s.length === 0) return \"\";\n    \n    let start = 0;\n    let end = 0;\n    \n    const expandAroundCenter = (left: number, right: number): number => {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1; // Length of palindrome\n    };\n    \n    for (let i = 0; i < s.length; i++) {\n        // Odd length palindromes (single center)\n        const len1 = expandAroundCenter(i, i);\n        // Even length palindromes (double center)\n        const len2 = expandAroundCenter(i, i + 1);\n        \n        const maxLen = Math.max(len1, len2);\n        \n        if (maxLen > end - start) {\n            start = i - Math.floor((maxLen - 1) / 2);\n            end = i + Math.floor(maxLen / 2);\n        }\n    }\n    \n    return s.substring(start, end + 1);\n}\n\n// ============== TEST CASES ==============\n\ninterface TestCase {\n    input: string;\n    description: string;\n}\n\nconst testCases: TestCase[] = [\n    { input: \"babad\", description: \"Multiple palindromes exist\" },\n    { input: \"cbbd\", description: \"Even length palindrome\" },\n    { input: \"a\", description: \"Single character\" },\n    { input: \"\", description: \"Empty string\" },\n    { input: \"ac\", description: \"No palindrome longer than 1\" },\n    { input: \"racecar\", description: \"Entire string is palindrome\" },\n    { input: \"aacabdkacaa\", description: \"Palindrome at the end\" },\n    { input: \"aaaa\", description: \"All same characters\" },\n    { input: \"abcba\", description: \"Odd length palindrome\" },\n    { input: \"abccba\", description: \"Even length full palindrome\" },\n];\n\n// Helper function to verify if a string is palindrome\nfunction isPalindrome(s: string): boolean {\n    return s === s.split(\"\").reverse().join(\"\");\n}\n\n// Run tests\nconsole.log(\"=== Longest Palindromic Substring Tests ===\\n\");\n\ntestCases.forEach(({ input, description }, index) => {\n    const result1 = longestPalindromicSubstring(input);\n    const result2 = longestPalindromicSubstringOptimized(input);\n    \n    console.log(`Test ${index + 1}: ${description}`);\n    console.log(`  Input: \"${input}\"`);\n    console.log(`  DP Result: \"${result1}\" (length: ${result1.length})`);\n    console.log(`  Optimized Result: \"${result2}\" (length: ${result2.length})`);\n    console.log(`  Is Valid Palindrome: ${isPalindrome(result1)}`);\n    console.log(`  Contains in Input: ${input.includes(result1)}`);\n    console.log();\n});\n\n// Performance comparison\nconsole.log(\"=== Performance Comparison ===\\n\");\n\nfunction measurePerformance(fn: (s: string) => string, input: string, name: string): void {\n    const iterations = 1000;\n    const start = performance.now();\n    \n    for (let i = 0; i < iterations; i++) {\n        fn(input);\n    }\n    \n    const end = performance.now();\n    console.log(`${name}: ${((end - start) / iterations).toFixed(4)}ms per call`);\n}\n\nconst longString = \"a\".repeat(100) + \"racecar\" + \"b\".repeat(100);\nconsole.log(`Testing with string of length ${longString.length}:`);\nmeasurePerformance(longestPalindromicSubstring, longString, \"DP Approach\");\nmeasurePerformance(longestPalindromicSubstringOptimized, longString, \"Expand Center\");\n```\n\n## Complexity Analysis\n\n### Dynamic Programming Approach\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n\u00b2) | Two nested loops iterating through all substrings |\n| **Space** | O(n\u00b2) | 2D boolean array of size n\u00d7n |\n\n### Expand Around Center Approach\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n\u00b2) | For each center, expansion can take O(n) |\n| **Space** | O(1) | Only uses constant extra variables |\n\n## Visual Representation of DP Table\n\n```\nFor string \"babad\":\n\n    b  a  b  a  d\nb [ T  F  T  F  F ]\na [    T  F  T  F ]\nb [       T  F  F ]\na [          T  F ]\nd [             T ]\n\nT = True (is palindrome)\nF = False (not palindrome)\n```\n\n## Output Example\n\n```\n=== Longest Palindromic Substring Tests ===\n\nTest 1: Multiple palindromes exist\n  Input: \"babad\"\n  DP Result: \"bab\" (length: 3)\n  Optimized Result: \"bab\" (length: 3)\n  Is Valid Palindrome: true\n  Contains in Input: true\n\nTest 2: Even length palindrome\n  Input: \"cbbd\"\n  DP Result: \"bb\" (length: 2)\n  Optimized Result: \"bb\" (length: 2)\n  Is Valid Palindrome: true\n  Contains in Input: true\n\nTest 6: Entire string is palindrome\n  Input: \"racecar\"\n  DP Result: \"racecar\" (length: 7)\n  Optimized Result: \"racecar\" (length: 7)\n  Is Valid Palindrome: true\n  Contains in Input: true\n```",
    "tokens_in": 64,
    "tokens_out": 2222,
    "cost": 0.16760999999999998,
    "duration_ms": 22451,
    "success": true,
    "error": null
  },
  {
    "test_name": "Complex Reasoning",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "A farmer needs to transport a wolf, a goat, and a cabbage across a river. The boat can only carry the farmer and one item at a time. If left alone:\n- The wolf will eat the goat\n- The goat will eat the cabbage\n\nFind the minimum number of crossings and explain each step.",
    "response": "[THINKING]\nThis is a classic river crossing puzzle. Let me work through it systematically.\n\nStarting position: Farmer, Wolf, Goat, Cabbage on the LEFT bank\nGoal: All on the RIGHT bank\n\nConstraints:\n- Wolf + Goat alone (without farmer) = Wolf eats Goat\n- Goat + Cabbage alone (without farmer) = Goat eats Cabbage\n- Wolf + Cabbage alone = Safe\n\nLet me denote:\n- L = Left bank\n- R = Right bank\n- \u2192 = Farmer crosses to right\n- \u2190 = Farmer crosses to left\n\nInitial: L = {W, G, C, F}, R = {}\n\nThe key insight is that the Goat can't be left with either the Wolf or the Cabbage. So the Goat needs special handling.\n\nStep 1: Farmer takes Goat across \u2192\nL = {W, C}, R = {G, F}\n(Wolf and Cabbage are safe together)\n\nStep 2: Farmer returns alone \u2190\nL = {W, C, F}, R = {G}\n(Goat is alone, safe)\n\nStep 3: Farmer takes Wolf across \u2192\nL = {C}, R = {W, G, F}\nBut wait - now Wolf and Goat are together with Farmer, so that's okay while Farmer is there.\n\nStep 4: Farmer takes Goat back \u2190\nL = {C, G, F}, R = {W}\n(This is the key trick - bringing the Goat back!)\n\nStep 5: Farmer takes Cabbage across \u2192\nL = {G}, R = {W, C, F}\n(Wolf and Cabbage are safe together)\n\nStep 6: Farmer returns alone \u2190\nL = {G, F}, R = {W, C}\n\nStep 7: Farmer takes Goat across \u2192\nL = {}, R = {W, G, C, F}\n\n\nDone in 7 crossings.\n\nLet me verify the solution works: After each step, either the farmer is present to supervise, or the remaining animals are compatible. The critical move is Step 4, where I bring the Goat back to prevent it from being eaten\u2014this allows me to safely transport the Wolf and Cabbage separately.\n\nThere's an equivalent approach: take the Cabbage first instead of the Wolf in Step 3. The Farmer moves the Goat across, returns alone, then transports the Cabbage. After bringing the Goat back again, the Farmer takes the Wolf across, returns, and finally ferries the Goat to the far side for the final crossing.\n\nNow I'm wondering if fewer than 7 crossings is possible. The theoretical minimum would be 5 crossings if we could move items freely\u2014one crossing per item plus two return trips. However, the constraint that the Goat can't be left alone with either the Wolf or Cabbage forces additional moves. The Goat must make a return trip to prevent dangerous pairings, which adds unavoidable steps to any solution.\n\nLet me verify whether 5 or 6 crossings could work. With 5 crossings following the pattern \u2192\u2190\u2192\u2190\u2192, I'd need to have two items safely on the right after the third crossing. The only stable pair is Wolf and Cabbage together, which means the Goat must have been moved first, then brought back. But this creates a logical impossibility\u2014I can't get all three items across in just 5 moves given these constraints. A 6-crossing solution faces similar issues. Therefore, 7 appears to be the actual minimum.\n[/THINKING]\n# River Crossing Puzzle Solution\n\n## Minimum Crossings: **7**\n\n## Step-by-Step Solution\n\n| Step | Action | Left Bank | Right Bank | Safe? |\n|------|--------|-----------|------------|-------|\n| Start | \u2014 | Wolf, Goat, Cabbage | \u2205 | \u2713 |\n| 1 | Take **Goat** across \u2192 | Wolf, Cabbage | Goat | \u2713 |\n| 2 | Return alone \u2190 | Wolf, Cabbage | Goat | \u2713 |\n| 3 | Take **Wolf** across \u2192 | Cabbage | Wolf, Goat | \u2713 |\n| 4 | Bring **Goat** back \u2190 | Cabbage, Goat | Wolf | \u2713 |\n| 5 | Take **Cabbage** across \u2192 | Goat | Wolf, Cabbage | \u2713 |\n| 6 | Return alone \u2190 | Goat | Wolf, Cabbage | \u2713 |\n| 7 | Take **Goat** across \u2192 | \u2205 | Wolf, Goat, Cabbage | \u2713 |\n\n## Key Insights\n\n1. **Goat is the problem** \u2014 it can't be left alone with either the wolf OR the cabbage\n2. **The trick** \u2014 you must bring the goat *back* at step 4\n3. **Wolf + Cabbage are safe** together (wolf won't eat cabbage)\n\n## Why 7 is Minimum\n\n- You need at least 5 crossings just to move 3 items (3 trips over + 2 returns)\n- The goat constraint forces 2 extra crossings (bringing it back, then taking it again)\n\n> **Note:** An alternate solution exists where you swap steps 3/5 (take cabbage before wolf) \u2014 still 7 crossings.",
    "tokens_in": 120,
    "tokens_out": 1809,
    "cost": 0.137475,
    "duration_ms": 27236,
    "success": true,
    "error": null
  },
  {
    "test_name": "Multi-step Task",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Create a complete TypeScript module for a simple task queue with these features:\n1. Add tasks with priority (1-5)\n2. Process tasks in priority order (highest first)\n3. Support async task execution\n4. Track task status (pending, running, completed, failed)\n5. Include proper TypeScript types\n6. Add JSDoc comments\n\nProvide the complete, working code.",
    "response": "```typescript\n/**\n * Priority levels for tasks (1 = lowest, 5 = highest)\n */\ntype Priority = 1 | 2 | 3 | 4 | 5;\n\n/**\n * Possible states of a task\n */\ntype TaskStatus = 'pending' | 'running' | 'completed' | 'failed';\n\n/**\n * Function type for task execution\n */\ntype TaskFunction<T> = () => Promise<T>;\n\n/**\n * Represents a task in the queue\n */\ninterface Task<T = unknown> {\n  /** Unique identifier for the task */\n  id: string;\n  /** Human-readable name for the task */\n  name: string;\n  /** Priority level (1-5, higher = more important) */\n  priority: Priority;\n  /** Current status of the task */\n  status: TaskStatus;\n  /** The async function to execute */\n  execute: TaskFunction<T>;\n  /** Result of the task execution (if completed) */\n  result?: T;\n  /** Error message (if failed) */\n  error?: string;\n  /** Timestamp when task was added */\n  createdAt: Date;\n  /** Timestamp when task started executing */\n  startedAt?: Date;\n  /** Timestamp when task completed or failed */\n  completedAt?: Date;\n}\n\n/**\n * Options for adding a new task\n */\ninterface AddTaskOptions<T> {\n  /** Human-readable name for the task */\n  name: string;\n  /** Priority level (1-5, default: 3) */\n  priority?: Priority;\n  /** The async function to execute */\n  execute: TaskFunction<T>;\n}\n\n/**\n * Event types emitted by the task queue\n */\ninterface TaskQueueEvents<T> {\n  taskAdded: (task: Task<T>) => void;\n  taskStarted: (task: Task<T>) => void;\n  taskCompleted: (task: Task<T>) => void;\n  taskFailed: (task: Task<T>) => void;\n  queueEmpty: () => void;\n}\n\n/**\n * Simple event emitter for task queue events\n */\nclass EventEmitter<T> {\n  private listeners: Map<keyof TaskQueueEvents<T>, Set<Function>> = new Map();\n\n  /**\n   * Subscribe to an event\n   * @param event - The event name to listen for\n   * @param callback - Function to call when event is emitted\n   */\n  on<K extends keyof TaskQueueEvents<T>>(\n    event: K,\n    callback: TaskQueueEvents<T>[K]\n  ): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Unsubscribe from an event\n   * @param event - The event name\n   * @param callback - The callback to remove\n   */\n  off<K extends keyof TaskQueueEvents<T>>(\n    event: K,\n    callback: TaskQueueEvents<T>[K]\n  ): void {\n    this.listeners.get(event)?.delete(callback);\n  }\n\n  /**\n   * Emit an event\n   * @param event - The event name\n   * @param args - Arguments to pass to listeners\n   */\n  protected emit<K extends keyof TaskQueueEvents<T>>(\n    event: K,\n    ...args: Parameters<TaskQueueEvents<T>[K]>\n  ): void {\n    this.listeners.get(event)?.forEach((callback) => callback(...args));\n  }\n}\n\n/**\n * A priority-based task queue with async execution support\n *\n * @example\n * ```typescript\n * const queue = new TaskQueue({ concurrency: 2 });\n *\n * queue.add({\n *   name: 'Important task',\n *   priority: 5,\n *   execute: async () => {\n *     // Do something important\n *     return 'done';\n *   }\n * });\n *\n * await queue.start();\n * ```\n */\nclass TaskQueue<T = unknown> extends EventEmitter<T> {\n  private tasks: Map<string, Task<T>> = new Map();\n  private pendingQueue: string[] = [];\n  private runningCount: number = 0;\n  private concurrency: number;\n  private isProcessing: boolean = false;\n  private idCounter: number = 0;\n\n  /**\n   * Creates a new TaskQueue instance\n   * @param options - Configuration options\n   * @param options.concurrency - Maximum number of concurrent tasks (default: 1)\n   */\n  constructor(options: { concurrency?: number } = {}) {\n    super();\n    this.concurrency = options.concurrency ?? 1;\n  }\n\n  /**\n   * Generates a unique task ID\n   */\n  private generateId(): string {\n    return `task_${++this.idCounter}_${Date.now()}`;\n  }\n\n  /**\n   * Adds a new task to the queue\n   * @param options - Task configuration\n   * @returns The created task object\n   */\n  add(options: AddTaskOptions<T>): Task<T> {\n    const task: Task<T> = {\n      id: this.generateId(),\n      name: options.name,\n      priority: options.priority ?? 3,\n      status: 'pending',\n      execute: options.execute,\n      createdAt: new Date(),\n    };\n\n    this.tasks.set(task.id, task);\n    this.insertByPriority(task.id, task.priority);\n    this.emit('taskAdded', task);\n\n    if (this.isProcessing) {\n      this.processNext();\n    }\n\n    return task;\n  }\n\n  /**\n   * Inserts a task ID into the pending queue sorted by priority\n   * @param taskId - The task ID to insert\n   * @param priority - The task's priority\n   */\n  private insertByPriority(taskId: string, priority: Priority): void {\n    let insertIndex = this.pendingQueue.length;\n\n    for (let i = 0; i < this.pendingQueue.length; i++) {\n      const existingTask = this.tasks.get(this.pendingQueue[i]);\n      if (existingTask && existingTask.priority < priority) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    this.pendingQueue.splice(insertIndex, 0, taskId);\n  }\n\n  /**\n   * Processes the next available task(s) in the queue\n   */\n  private async processNext(): Promise<void> {\n    while (\n      this.runningCount < this.concurrency &&\n      this.pendingQueue.length > 0\n    ) {\n      const taskId = this.pendingQueue.shift();\n      if (!taskId) continue;\n\n      const task = this.tasks.get(taskId);\n      if (!task || task.status !== 'pending') continue;\n\n      this.runningCount++;\n      this.executeTask(task);\n    }\n\n    if (this.pendingQueue.length === 0 && this.runningCount === 0) {\n      this.emit('queueEmpty');\n    }\n  }\n\n  /**\n   * Executes a single task\n   * @param task - The task to execute\n   */\n  private async executeTask(task: Task<T>): Promise<void> {\n    task.status = 'running';\n    task.startedAt = new Date();\n    this.emit('taskStarted', task);\n\n    try {\n      const result = await task.execute();\n      task.result = result;\n      task.status = 'completed';\n      task.completedAt = new Date();\n      this.emit('taskCompleted', task);\n    } catch (error) {\n      task.status = 'failed';\n      task.error = error instanceof Error ? error.message : String(error);\n      task.completedAt = new Date();\n      this.emit('taskFailed', task);\n    } finally {\n      this.runningCount--;\n      this.processNext();\n    }\n  }\n\n  /**\n   * Starts processing the queue\n   * @returns Promise that resolves when the queue is empty\n   */\n  async start(): Promise<void> {\n    if (this.isProcessing) return;\n\n    this.isProcessing = true;\n\n    return new Promise<void>((resolve) => {\n      if (this.pendingQueue.length === 0 && this.runningCount === 0) {\n        this.isProcessing = false;\n        resolve();\n        return;\n      }\n\n      const onEmpty = () => {\n        this.off('queueEmpty', onEmpty);\n        this.isProcessing = false;\n        resolve();\n      };\n\n      this.on('queueEmpty', onEmpty);\n      this.processNext();\n    });\n  }\n\n  /**\n   * Pauses queue processing (running tasks will complete)\n   */\n  pause(): void {\n    this.isProcessing = false;\n  }\n\n  /**\n   * Gets a task by ID\n   * @param taskId - The task ID\n   * @returns The task or undefined if not found\n   */\n  getTask(taskId: string): Task<T> | undefined {\n    return this.tasks.get(taskId);\n  }\n\n  /**\n   * Gets all tasks with a specific status\n   * @param status - The status to filter by\n   * @returns Array of matching tasks\n   */\n  getTasksByStatus(status: TaskStatus): Task<T>[] {\n    return Array.from(this.tasks.values()).filter(\n      (task) => task.status === status\n    );\n  }\n\n  /**\n   * Gets all tasks in the queue\n   * @returns Array of all tasks\n   */\n  getAllTasks(): Task<T>[] {\n    return Array.from(this.tasks.values());\n  }\n\n  /**\n   * Removes a completed or failed task from the queue\n   * @param taskId - The task ID to remove\n   * @returns true if removed, false if not found or still running\n   */\n  remove(taskId: string): boolean {\n    const task = this.tasks.get(taskId);\n    if (!task) return false;\n\n    if (task.status === 'running') return false;\n\n    if (task.status === 'pending') {\n      const index = this.pendingQueue.indexOf(taskId);\n      if (index > -1) {\n        this.pendingQueue.splice(index, 1);\n      }\n    }\n\n    return this.tasks.delete(taskId);\n  }\n\n  /**\n   * Clears all completed and failed tasks\n   * @returns Number of tasks cleared\n   */\n  clearCompleted(): number {\n    let cleared = 0;\n    for (const [id, task] of this.tasks) {\n      if (task.status === 'completed' || task.status === 'failed') {\n        this.tasks.delete(id);\n        cleared++;\n      }\n    }\n    return cleared;\n  }\n\n  /**\n   * Gets queue statistics\n   * @returns Object with task counts by status\n   */\n  getStats(): Record<TaskStatus, number> & { total: number } {\n    const stats = {\n      pending: 0,\n      running: 0,\n      completed: 0,\n      failed: 0,\n      total: this.tasks.size,\n    };\n\n    for (const task of this.tasks.values()) {\n      stats[task.status]++;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Gets the current queue size (pending tasks only)\n   */\n  get size(): number {\n    return this.pendingQueue.length;\n  }\n\n  /**\n   * Checks if the queue is currently processing\n   */\n  get processing(): boolean {\n    return this.isProcessing;\n  }\n}\n\nexport {\n  TaskQueue,\n  Task,\n  TaskStatus,\n  Priority,\n  TaskFunction,\n  AddTaskOptions,\n  TaskQueueEvents,\n};\n```",
    "tokens_in": 105,
    "tokens_out": 2960,
    "cost": 0.223575,
    "duration_ms": 27407,
    "success": true,
    "error": null
  },
  {
    "test_name": "Code Review",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Review this JavaScript code and identify all issues (bugs, bad practices, potential errors). Rate severity (high/medium/low) for each:\n\n```javascript\n\nasync function fetchUserData(userId) {\n  const response = await fetch(`/api/users/${userId}`);\n  const data = response.json();\n  return data;\n}\n\nfunction processUsers(users) {\n  let result = [];\n  for (let i = 0; i <= users.length; i++) {\n    if (users[i].active == true) {\n      result.push(users[i].name.toUpperCase());\n    }\n  }\n  return result;\n}\n\nclass DataProcessor {\n  data = null;\n\n  async load(url) {\n    this.data = await fetch(url).then(r => r.json());\n  }\n\n  process() {\n    return this.data.map(item => {\n      item.processed = true;\n      return item;\n    });\n  }\n}\n```",
    "response": "# Code Review: Issues Identified\n\n## 1. `fetchUserData` Function\n\n### Issue 1.1: Missing `await` on `response.json()`\n**Severity: HIGH**\n```javascript\nconst data = response.json(); // Returns a Promise, not actual data\n```\n**Fix:** `const data = await response.json();`\n\n### Issue 1.2: No error handling for failed requests\n**Severity: HIGH**\n```javascript\n// No check for response.ok or try/catch\n```\n**Fix:**\n```javascript\nif (!response.ok) throw new Error(`HTTP ${response.status}`);\n```\n\n---\n\n## 2. `processUsers` Function\n\n### Issue 2.1: Off-by-one error (out of bounds)\n**Severity: HIGH**\n```javascript\nfor (let i = 0; i <= users.length; i++) // Should be <, not <=\n```\nLast iteration accesses `users[users.length]` which is `undefined`.\n\n### Issue 2.2: No null check before accessing properties\n**Severity: HIGH**\n```javascript\nusers[i].active // Will throw if users[i] is undefined/null\nusers[i].name.toUpperCase() // Will throw if name is undefined\n```\n\n### Issue 2.3: Loose equality comparison\n**Severity: LOW**\n```javascript\nusers[i].active == true // Should use === for strict comparison\n```\n\n---\n\n## 3. `DataProcessor` Class\n\n### Issue 3.1: `process()` called before `load()` causes crash\n**Severity: HIGH**\n```javascript\nprocess() {\n  return this.data.map(...) // this.data is null initially\n}\n```\n\n### Issue 3.2: Mutates original data objects\n**Severity: MEDIUM**\n```javascript\nitem.processed = true; // Modifies original objects, not copies\n```\n**Fix:** `return { ...item, processed: true };`\n\n### Issue 3.3: No error handling in `load()`\n**Severity: MEDIUM**\n\n---\n\n## Summary Table\n\n| Issue | Location | Severity |\n|-------|----------|----------|\n| Missing await on `.json()` | fetchUserData | HIGH |\n| No HTTP error handling | fetchUserData | HIGH |\n| Off-by-one loop error | processUsers | HIGH |\n| No null safety | processUsers | HIGH |\n| Loose equality `==` | processUsers | LOW |\n| Null data access | DataProcessor.process | HIGH |\n| Data mutation | DataProcessor.process | MEDIUM |\n| No error handling | DataProcessor.load | MEDIUM |",
    "tokens_in": 250,
    "tokens_out": 616,
    "cost": 0.049949999999999994,
    "duration_ms": 10082,
    "success": true,
    "error": null
  },
  {
    "test_name": "SQL Optimisation",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Analyse this SQL query and optimise it for better performance. Explain the issues and provide the optimised query with index recommendations:\n\n```sql\n\n-- Slow query that needs optimisation\nSELECT\n    u.id,\n    u.name,\n    u.email,\n    COUNT(o.id) as order_count,\n    SUM(o.total) as total_spent,\n    (SELECT MAX(created_at) FROM orders WHERE user_id = u.id) as last_order_date\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id\nWHERE u.created_at > '2024-01-01'\nAND u.status = 'active'\nAND (SELECT COUNT(*) FROM orders WHERE user_id = u.id AND status = 'completed') > 5\nGROUP BY u.id, u.name, u.email\nHAVING SUM(o.total) > 1000\nORDER BY total_spent DESC\nLIMIT 100;\n\n```",
    "response": "# SQL Query Analysis and Optimization\n\n## Issues Identified\n\n### 1. **Correlated Subqueries in SELECT and WHERE**\nThe query contains two correlated subqueries that execute **once per row**, causing N+1 query problems:\n- `(SELECT MAX(created_at) FROM orders WHERE user_id = u.id)` - runs for every user\n- `(SELECT COUNT(*) FROM orders WHERE user_id = u.id AND status = 'completed') > 5` - runs for every user\n\n### 2. **Redundant Table Scans**\nThe `orders` table is accessed 3 times:\n- Main JOIN\n- Subquery for `last_order_date`\n- Subquery for completed order count filter\n\n### 3. **GROUP BY Includes Non-Aggregated Columns**\nGrouping by `u.name` and `u.email` is unnecessary if `u.id` is the primary key.\n\n### 4. **Missing Index Utilization**\nThe WHERE clause filters on `created_at` and `status` without apparent composite index support.\n\n---\n\n## Optimized Query\n\n```sql\n-- Optimized query using CTEs and eliminating correlated subqueries\nWITH user_order_stats AS (\n    SELECT \n        user_id,\n        COUNT(*) AS order_count,\n        SUM(total) AS total_spent,\n        MAX(created_at) AS last_order_date,\n        COUNT(CASE WHEN status = 'completed' THEN 1 END) AS completed_count\n    FROM orders\n    GROUP BY user_id\n)\nSELECT\n    u.id,\n    u.name,\n    u.email,\n    COALESCE(uos.order_count, 0) AS order_count,\n    COALESCE(uos.total_spent, 0) AS total_spent,\n    uos.last_order_date\nFROM users u\nINNER JOIN user_order_stats uos ON uos.user_id = u.id\nWHERE u.created_at > '2024-01-01'\n  AND u.status = 'active'\n  AND uos.completed_count > 5\n  AND uos.total_spent > 1000\nORDER BY uos.total_spent DESC\nLIMIT 100;\n```\n\n---\n\n## Key Optimizations Explained\n\n| Issue | Solution | Benefit |\n|-------|----------|---------|\n| Correlated subqueries | Pre-aggregate in CTE | Single pass over orders table |\n| Multiple orders scans | Single aggregation query | Reduces I/O by ~66% |\n| HAVING clause | Moved to WHERE | Filter applied earlier in execution |\n| LEFT JOIN | Changed to INNER JOIN | Users need >5 orders anyway |\n\n---\n\n## Recommended Indexes\n\n```sql\n-- Primary index for user filtering (covers WHERE conditions)\nCREATE INDEX idx_users_status_created \nON users(status, created_at) \nINCLUDE (id, name, email);\n\n-- Index for orders aggregation (covers the CTE query)\nCREATE INDEX idx_orders_user_status_total_created \nON orders(user_id, status, total, created_at);\n\n-- If your DB supports it, a covering index for orders:\nCREATE INDEX idx_orders_user_covering \nON orders(user_id) \nINCLUDE (status, total, created_at);\n```\n\n---\n\n## Execution Plan Comparison\n\n```\nORIGINAL QUERY:\n\u251c\u2500\u2500 Seq Scan on users (filtered)\n\u2502   \u251c\u2500\u2500 Correlated Subquery 1 (per row) \u2500\u2500\u2192 Seq Scan orders\n\u2502   \u2514\u2500\u2500 Correlated Subquery 2 (per row) \u2500\u2500\u2192 Seq Scan orders\n\u251c\u2500\u2500 Hash Left Join with orders\n\u2514\u2500\u2500 Sort + Limit\n\nOPTIMIZED QUERY:\n\u251c\u2500\u2500 CTE: Single Index Scan on orders (grouped)\n\u251c\u2500\u2500 Index Scan on users (status, created_at)\n\u251c\u2500\u2500 Hash Join with CTE results\n\u2514\u2500\u2500 Sort + Limit\n```\n\n---\n\n## Alternative: Window Function Approach\n\nFor databases with good window function optimization:\n\n```sql\nSELECT \n    id, name, email, order_count, total_spent, last_order_date\nFROM (\n    SELECT\n        u.id,\n        u.name,\n        u.email,\n        COUNT(o.id) AS order_count,\n        SUM(o.total) AS total_spent,\n        MAX(o.created_at) AS last_order_date,\n        SUM(CASE WHEN o.status = 'completed' THEN 1 ELSE 0 END) AS completed_count\n    FROM users u\n    INNER JOIN orders o ON o.user_id = u.id\n    WHERE u.created_at > '2024-01-01'\n      AND u.status = 'active'\n    GROUP BY u.id, u.name, u.email\n) subq\nWHERE completed_count > 5\n  AND total_spent > 1000\nORDER BY total_spent DESC\nLIMIT 100;\n```\n\nThis version works well when most filtered users have orders, avoiding the CTE materialization overhead.",
    "tokens_in": 248,
    "tokens_out": 1224,
    "cost": 0.09552000000000001,
    "duration_ms": 17087,
    "success": true,
    "error": null
  },
  {
    "test_name": "API Design",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Design a RESTful API for a task management system with the following requirements:\n1. Users can create, read, update, delete tasks\n2. Tasks have: title, description, status, priority, due date, assignee\n3. Tasks can have comments and attachments\n4. Support filtering, sorting, and pagination\n5. Include authentication and authorisation\n\nProvide:\n- API endpoint specifications (method, path, request/response)\n- Authentication approach\n- Error handling strategy\n- Rate limiting recommendations",
    "response": "# Task Management System RESTful API Design\n\n## Authentication Approach\n\n### JWT-Based Authentication\n\n```\nAuthentication Flow:\n1. User logs in with credentials\n2. Server returns access token (15min) + refresh token (7 days)\n3. Client includes access token in Authorization header\n4. Refresh token used to obtain new access tokens\n```\n\n**Token Structure:**\n```json\n{\n  \"sub\": \"user_id\",\n  \"email\": \"user@example.com\",\n  \"roles\": [\"user\", \"admin\"],\n  \"permissions\": [\"task:read\", \"task:write\", \"task:delete\"],\n  \"iat\": 1699000000,\n  \"exp\": 1699000900\n}\n```\n\n---\n\n## API Endpoint Specifications\n\n### Base URL\n```\nhttps://api.taskmanager.com/v1\n```\n\n### Standard Headers\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\nAccept: application/json\nX-Request-ID: <uuid>  (for tracing)\n```\n\n---\n\n## 1. Authentication Endpoints\n\n### POST /auth/register\n**Create new user account**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"email\": \"user@example.com\",\n      \"password\": \"SecurePass123!\",\n      \"name\": \"John Doe\"\n    }\n\nResponse (201 Created):\n  {\n    \"data\": {\n      \"id\": \"usr_abc123\",\n      \"email\": \"user@example.com\",\n      \"name\": \"John Doe\",\n      \"created_at\": \"2024-01-15T10:30:00Z\"\n    },\n    \"meta\": {\n      \"request_id\": \"req_xyz789\"\n    }\n  }\n\nErrors:\n  - 400: Invalid input (validation failed)\n  - 409: Email already exists\n```\n\n### POST /auth/login\n**Authenticate user**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"email\": \"user@example.com\",\n      \"password\": \"SecurePass123!\"\n    }\n\nResponse (200 OK):\n  {\n    \"data\": {\n      \"access_token\": \"eyJhbGciOiJIUzI1NiIs...\",\n      \"refresh_token\": \"eyJhbGciOiJIUzI1NiIs...\",\n      \"token_type\": \"Bearer\",\n      \"expires_in\": 900,\n      \"user\": {\n        \"id\": \"usr_abc123\",\n        \"email\": \"user@example.com\",\n        \"name\": \"John Doe\",\n        \"roles\": [\"user\"]\n      }\n    }\n  }\n\nErrors:\n  - 401: Invalid credentials\n  - 423: Account locked (too many failed attempts)\n```\n\n### POST /auth/refresh\n**Refresh access token**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"refresh_token\": \"eyJhbGciOiJIUzI1NiIs...\"\n    }\n\nResponse (200 OK):\n  {\n    \"data\": {\n      \"access_token\": \"eyJhbGciOiJIUzI1NiIs...\",\n      \"expires_in\": 900\n    }\n  }\n\nErrors:\n  - 401: Invalid or expired refresh token\n```\n\n### POST /auth/logout\n**Invalidate tokens**\n\n```yaml\nRequest:\n  Headers:\n    Authorization: Bearer <access_token>\n  Body:\n    {\n      \"refresh_token\": \"eyJhbGciOiJIUzI1NiIs...\"\n    }\n\nResponse (204 No Content)\n```\n\n---\n\n## 2. Task Endpoints\n\n### GET /tasks\n**List tasks with filtering, sorting, and pagination**\n\n```yaml\nRequest:\n  Query Parameters:\n    # Pagination\n    page: integer (default: 1)\n    per_page: integer (default: 20, max: 100)\n    \n    # Filtering\n    status: enum (pending, in_progress, completed, cancelled)\n    priority: enum (low, medium, high, urgent)\n    assignee_id: string\n    created_by: string\n    due_date_from: ISO8601 date\n    due_date_to: ISO8601 date\n    search: string (searches title and description)\n    \n    # Sorting\n    sort: string (e.g., \"created_at\", \"-due_date\", \"priority,-created_at\")\n    \n    # Field selection\n    fields: string (comma-separated, e.g., \"id,title,status\")\n\n  Example:\n    GET /tasks?status=pending&priority=high&sort=-due_date&page=1&per_page=10\n\nResponse (200 OK):\n  {\n    \"data\": [\n      {\n        \"id\": \"tsk_abc123\",\n        \"title\": \"Implement user authentication\",\n        \"description\": \"Add JWT-based auth to the API\",\n        \"status\": \"in_progress\",\n        \"priority\": \"high\",\n        \"due_date\": \"2024-01-20T23:59:59Z\",\n        \"assignee\": {\n          \"id\": \"usr_def456\",\n          \"name\": \"Jane Smith\",\n          \"email\": \"jane@example.com\"\n        },\n        \"created_by\": {\n          \"id\": \"usr_abc123\",\n          \"name\": \"John Doe\"\n        },\n        \"comments_count\": 5,\n        \"attachments_count\": 2,\n        \"created_at\": \"2024-01-15T10:30:00Z\",\n        \"updated_at\": \"2024-01-16T14:20:00Z\"\n      }\n    ],\n    \"meta\": {\n      \"pagination\": {\n        \"current_page\": 1,\n        \"per_page\": 10,\n        \"total_pages\": 5,\n        \"total_count\": 47\n      },\n      \"filters_applied\": {\n        \"status\": \"pending\",\n        \"priority\": \"high\"\n      }\n    },\n    \"links\": {\n      \"self\": \"/tasks?page=1&per_page=10\",\n      \"first\": \"/tasks?page=1&per_page=10\",\n      \"prev\": null,\n      \"next\": \"/tasks?page=2&per_page=10\",\n      \"last\": \"/tasks?page=5&per_page=10\"\n    }\n  }\n```\n\n### POST /tasks\n**Create a new task**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"title\": \"Implement user authentication\",\n      \"description\": \"Add JWT-based auth to the API\",\n      \"status\": \"pending\",\n      \"priority\": \"high\",\n      \"due_date\": \"2024-01-20T23:59:59Z\",\n      \"assignee_id\": \"usr_def456\",\n      \"tags\": [\"backend\", \"security\"]\n    }\n\nResponse (201 Created):\n  Headers:\n    Location: /tasks/tsk_abc123\n  Body:\n    {\n      \"data\": {\n        \"id\": \"tsk_abc123\",\n        \"title\": \"Implement user authentication\",\n        \"description\": \"Add JWT-based auth to the API\",\n        \"status\": \"pending\",\n        \"priority\": \"high\",\n        \"due_date\": \"2024-01-20T23:59:59Z\",\n        \"assignee\": {\n          \"id\": \"usr_def456\",\n          \"name\": \"Jane Smith\",\n          \"email\": \"jane@example.com\"\n        },\n        \"created_by\": {\n          \"id\": \"usr_abc123\",\n          \"name\": \"John Doe\"\n        },\n        \"tags\": [\"backend\", \"security\"],\n        \"comments_count\": 0,\n        \"attachments_count\": 0,\n        \"created_at\": \"2024-01-15T10:30:00Z\",\n        \"updated_at\": \"2024-01-15T10:30:00Z\"\n      }\n    }\n\nErrors:\n  - 400: Validation error\n  - 404: Assignee not found\n```\n\n### GET /tasks/{task_id}\n**Get task details**\n\n```yaml\nRequest:\n  Path Parameters:\n    task_id: string (required)\n  Query Parameters:\n    include: string (comma-separated: comments, attachments, history)\n\n  Example:\n    GET /tasks/tsk_abc123?include=comments,attachments\n\nResponse (200 OK):\n  {\n    \"data\": {\n      \"id\": \"tsk_abc123\",\n      \"title\": \"Implement user authentication\",\n      \"description\": \"Add JWT-based auth to the API\",\n      \"status\": \"in_progress\",\n      \"priority\": \"high\",\n      \"due_date\": \"2024-01-20T23:59:59Z\",\n      \"assignee\": {\n        \"id\": \"usr_def456\",\n        \"name\": \"Jane Smith\",\n        \"email\": \"jane@example.com\"\n      },\n      \"created_by\": {\n        \"id\": \"usr_abc123\",\n        \"name\": \"John Doe\"\n      },\n      \"tags\": [\"backend\", \"security\"],\n      \"created_at\": \"2024-01-15T10:30:00Z\",\n      \"updated_at\": \"2024-01-16T14:20:00Z\",\n      \"comments\": [\n        {\n          \"id\": \"cmt_xyz789\",\n          \"content\": \"Started working on this\",\n          \"author\": {\n            \"id\": \"usr_def456\",\n            \"name\": \"Jane Smith\"\n          },\n          \"created_at\": \"2024-01-16T09:00:00Z\"\n        }\n      ],\n      \"attachments\": [\n        {\n          \"id\": \"att_qrs456\",\n          \"filename\": \"requirements.pdf\",\n          \"mime_type\": \"application/pdf\",\n          \"size_bytes\": 102400,\n          \"url\": \"https://storage.taskmanager.com/attachments/att_qrs456\",\n          \"uploaded_by\": {\n            \"id\": \"usr_abc123\",\n            \"name\": \"John Doe\"\n          },\n          \"created_at\": \"2024-01-15T11:00:00Z\"\n        }\n      ]\n    }\n  }\n\nErrors:\n  - 404: Task not found\n  - 403: Access denied\n```\n\n### PUT /tasks/{task_id}\n**Full update of task**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"title\": \"Implement user authentication\",\n      \"description\": \"Add JWT-based auth with refresh tokens\",\n      \"status\": \"in_progress\",\n      \"priority\": \"urgent\",\n      \"due_date\": \"2024-01-18T23:59:59Z\",\n      \"assignee_id\": \"usr_def456\",\n      \"tags\": [\"backend\", \"security\", \"priority\"]\n    }\n\nResponse (200 OK):\n  {\n    \"data\": {\n      // Full task object\n    }\n  }\n\nErrors:\n  - 400: Validation error\n  - 404: Task not found\n  - 403: Not authorized to update\n  - 409: Conflict (concurrent update)\n```\n\n### PATCH /tasks/{task_id}\n**Partial update of task**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"status\": \"completed\",\n      \"priority\": \"low\"\n    }\n\nResponse (200 OK):\n  {\n    \"data\": {\n      // Full task object with updates\n    }\n  }\n\nErrors:\n  - 400: Validation error\n  - 404: Task not found\n  - 403: Not authorized to update\n```\n\n### DELETE /tasks/{task_id}\n**Delete task**\n\n```yaml\nResponse (204 No Content)\n\nErrors:\n  - 404: Task not found\n  - 403: Not authorized to delete\n```\n\n---\n\n## 3. Comment Endpoints\n\n### GET /tasks/{task_id}/comments\n**List comments for a task**\n\n```yaml\nRequest:\n  Query Parameters:\n    page: integer (default: 1)\n    per_page: integer (default: 20)\n    sort: string (default: \"-created_at\")\n\nResponse (200 OK):\n  {\n    \"data\": [\n      {\n        \"id\": \"cmt_xyz789\",\n        \"content\": \"Started working on this task\",\n        \"author\": {\n          \"id\": \"usr_def456\",\n          \"name\": \"Jane Smith\",\n          \"avatar_url\": \"https://...\"\n        },\n        \"mentions\": [\n          {\n            \"id\": \"usr_abc123\",\n            \"name\": \"John Doe\"\n          }\n        ],\n        \"edited\": false,\n        \"created_at\": \"2024-01-16T09:00:00Z\",\n        \"updated_at\": \"2024-01-16T09:00:00Z\"\n      }\n    ],\n    \"meta\": {\n      \"pagination\": {\n        \"current_page\": 1,\n        \"per_page\": 20,\n        \"total_count\": 5\n      }\n    }\n  }\n```\n\n### POST /tasks/{task_id}/comments\n**Add comment to task**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"content\": \"Great progress! @usr_abc123 please review when ready.\",\n      \"mentions\": [\"usr_abc123\"]\n    }\n\nResponse (201 Created):\n  {\n    \"data\": {\n      \"id\": \"cmt_new123\",\n      \"content\": \"Great progress! @usr_abc123 please review when ready.\",\n      \"author\": {\n        \"id\": \"usr_def456\",\n        \"name\": \"Jane Smith\"\n      },\n      \"mentions\": [\n        {\n          \"id\": \"usr_abc123\",\n          \"name\": \"John Doe\"\n        }\n      ],\n      \"created_at\": \"2024-01-16T15:30:00Z\"\n    }\n  }\n```\n\n### PATCH /tasks/{task_id}/comments/{comment_id}\n**Update comment**\n\n```yaml\nRequest:\n  Body:\n    {\n      \"content\": \"Updated comment content\"\n    }\n\nResponse (200 OK):\n  {\n    \"data\": {\n      \"id\": \"cmt_xyz789\",\n      \"content\": \"Updated comment content\",\n      \"edited\": true,\n      \"updated_at\": \"2024-01-16T16:00:00Z\"\n    }\n  }\n\nErrors:\n  - 403: Can only edit own comments (within 15 minutes)\n```\n\n### DELETE /tasks/{task_id}/comments/{comment_id}\n**Delete comment**\n\n```yaml\nResponse (204 No Content)\n\nErrors:\n  - 403: Can only delete own comments or requires admin role\n```\n\n---\n\n## 4. Attachment Endpoints\n\n### GET /tasks/{task_id}/attachments\n**List attachments for a task**\n\n```yaml\nResponse (200 OK):\n  {\n    \"data\": [\n      {\n        \"id\": \"att_qrs456\",\n        \"filename\": \"requirements.pdf\",\n        \"mime_type\": \"application/pdf\",\n        \"size_bytes\": 102400,\n        \"download_url\": \"https://storage.taskmanager.com/attachments/att_qrs456\",\n        \"thumbnail_url\": null,\n        \"uploaded_by\": {\n          \"id\": \"usr_abc123\",\n          \"name\": \"John Doe\"\n        },\n        \"created_at\": \"2024-01-15T11:00:00Z\"\n      }\n    ]\n  }\n```\n\n### POST /tasks/{task_id}/attachments\n**Upload attachment (multipart/form-data)**\n\n```yaml\nRequest:\n  Headers:\n    Content-Type: multipart/form-data\n  Body:\n    file: <binary>\n    description: \"Project requirements document\" (optional)\n\nResponse (201 Created):\n  {\n    \"data\": {\n      \"id\": \"att_new789\",\n      \"filename\": \"spec.docx\",\n      \"mime_type\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n      \"size_bytes\": 51200,\n      \"download_url\": \"https://storage.taskmanager.com/attachments/att_new789\",\n      \"uploaded_by\": {\n        \"id\": \"usr_abc123\",\n        \"name\": \"John Doe\"\n      },\n      \"created_at\": \"2024-01-16T10:00:00Z\"\n    }\n  }\n\nErrors:\n  - 400: Invalid file type\n  - 413: File too large (max 25MB)\n```\n\n### GET /tasks/{task_id}/attachments/{attachment_id}\n**Get attachment download URL**\n\n```yaml\nResponse (200 OK):\n  {\n    \"data\": {\n      \"id\": \"att_qrs456\",\n      \"filename\": \"requirements.pdf\",\n      \"download_url\": \"https://storage.taskmanager.com/attachments/att_qrs456?token=...\",\n      \"expires_at\": \"2024-01-16T11:00:00Z\"\n    }\n  }\n```\n\n### DELETE /tasks/{task_id}/attachments/{attachment_id}\n**Delete attachment**\n\n```yaml\nResponse (204 No Content)\n```\n\n---\n\n## 5. User Endpoints\n\n### GET /users\n**List users (for assignee selection)**\n\n```yaml\nRequest:\n  Query Parameters:\n    search: string (name or email)\n    page: integer\n    per_page: integer\n\nResponse (200 OK):\n  {\n    \"data\": [\n      {\n        \"id\": \"usr_abc123\",\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"avatar_url\": \"https://...\"\n      }\n    ]\n  }\n```\n\n### GET /users/me\n**Get current user profile**\n\n```yaml\nResponse (200 OK):\n  {\n    \"data\": {\n      \"id\": \"usr_abc123\",\n      \"name\": \"John Doe\",\n      \"email\": \"john@example.com\",\n      \"roles\": [\"user\"],\n      \"permissions\": [\"task:read\", \"task:write\"],\n      \"preferences\": {\n        \"timezone\": \"America/New_York\",\n        \"notifications_enabled\": true\n      },\n      \"created_at\": \"2024-01-01T00:00:00Z\"\n    }\n  }\n```\n\n---\n\n## Error Handling Strategy\n\n### Standard Error Response Format\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"The request contains invalid data\",\n    \"details\": [\n      {\n        \"field\": \"due_date\",\n        \"message\": \"Due date must be in the future\",\n        \"code\": \"INVALID_DATE\"\n      },\n      {\n        \"field\": \"priority\",\n        \"message\": \"Priority must be one of: low, medium, high, urgent\",\n        \"code\": \"INVALID_ENUM\"\n      }\n    ],\n    \"request_id\": \"req_xyz789\",\n    \"documentation_url\": \"https://docs.taskmanager.com/errors/VALIDATION_ERROR\"\n  }\n}\n```\n\n### HTTP Status Codes\n\n```yaml\nSuccess Codes:\n  200 OK: Successful GET, PUT, PATCH\n  201 Created: Successful POST (resource created)\n  204 No Content: Successful DELETE\n\nClient Error Codes:\n  400 Bad Request:\n    - VALIDATION_ERROR: Invalid input data\n    - MALFORMED_JSON: JSON parsing failed\n    - INVALID_QUERY_PARAM: Bad query parameter\n    \n  401 Unauthorized:\n    - AUTHENTICATION_REQUIRED: No token provided\n    - INVALID_TOKEN: Token is invalid\n    - TOKEN_EXPIRED: Token has expired\n    \n  403 Forbidden:\n    - ACCESS_DENIED: User lacks permission\n    - RESOURCE_FORBIDDEN: Cannot access this resource\n    \n  404 Not Found:\n    - RESOURCE_NOT_FOUND: Entity doesn't exist\n    - ENDPOINT_NOT_FOUND: Invalid API endpoint\n    \n  405 Method Not Allowed:\n    - METHOD_NOT_ALLOWED: HTTP method not supported\n    \n  409 Conflict:\n    - DUPLICATE_RESOURCE: Resource already exists\n    - CONCURRENT_MODIFICATION: Resource was modified\n    \n  413 Payload Too Large:\n    - FILE_TOO_LARGE: Upload exceeds limit\n    \n  422 Unprocessable Entity:\n    - BUSINESS_RULE_VIOLATION: Business logic error\n    \n  429 Too Many Requests:\n    - RATE_LIMIT_EXCEEDED: Too many requests\n\nServer Error Codes:\n  500 Internal Server Error:\n    - INTERNAL_ERROR: Unexpected server error\n    \n  502 Bad Gateway:\n    - UPSTREAM_ERROR: External service failed\n    \n  503 Service Unavailable:\n    - SERVICE_UNAVAILABLE: Temporary outage\n```\n\n### Error Code Implementation\n\n```python\n# Python/FastAPI example\nfrom enum import Enum\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\nclass ErrorCode(str, Enum):\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    AUTHENTICATION_REQUIRED = \"AUTHENTICATION_REQUIRED\"\n    INVALID_TOKEN = \"INVALID_TOKEN\"\n    TOKEN_EXPIRED = \"TOKEN_EXPIRED\"\n    ACCESS_DENIED = \"ACCESS_DENIED\"\n    RESOURCE_NOT_FOUND = \"RESOURCE_NOT_FOUND\"\n    DUPLICATE_RESOURCE = \"DUPLICATE_RESOURCE\"\n    RATE_LIMIT_EXCEEDED = \"RATE_LIMIT_EXCEEDED\"\n    INTERNAL_ERROR = \"INTERNAL_ERROR\"\n\nclass ErrorDetail(BaseModel):\n    field: Optional[str] = None\n    message: str\n    code: str\n\nclass ErrorResponse(BaseModel):\n    code: ErrorCode\n    message: str\n    details: Optional[List[ErrorDetail]] = None\n    request_id: str\n    documentation_url: Optional[str] = None\n\nclass APIException(Exception):\n    def __init__(\n        self,\n        status_code: int,\n        code: ErrorCode,\n        message: str,\n        details: List[ErrorDetail] = None\n    ):\n        self.status_code = status_code\n        self.code = code\n        self.message = message\n        self.details = details\n\n# Usage\nraise APIException(\n    status_code=400,\n    code=ErrorCode.VALIDATION_ERROR,\n    message=\"Invalid task data\",\n    details=[\n        ErrorDetail(field=\"due_date\", message=\"Must be in future\", code=\"INVALID_DATE\")\n    ]\n)\n```\n\n---\n\n## Rate Limiting Recommendations\n\n### Rate Limit Tiers\n\n```yaml\nAnonymous/Unauthenticated:\n  - 20 requests per minute\n  - 100 requests per hour\n  \nFree Tier:\n  - 60 requests per minute\n  - 1,000 requests per hour\n  - 10,000 requests per day\n  \nPro Tier:\n  - 300 requests per minute\n  - 10,000 requests per hour\n  - 100,000 requests per day\n  \nEnterprise:\n  - 1,000 requests per minute\n  - Custom limits\n  - Dedicated rate limit pools\n```\n\n### Endpoint-Specific Limits\n\n```yaml\nHigh-Cost Operations:\n  POST /tasks/*/attachments: 10 per minute (uploads)\n  POST /auth/login: 5 per minute (brute force protection)\n  GET /tasks (with complex filters): 30 per minute\n  \nStandard Operations:\n  POST /tasks: 60 per minute\n  PUT/PATCH /tasks/*: 120 per minute\n  \nLow-Cost Operations:\n  GET /tasks/*: 300 per minute\n  GET /users: 300 per minute\n```\n\n### Rate Limit Headers\n\n```yaml\nResponse Headers:\n  X-RateLimit-Limit: 60\n  X-RateLimit-Remaining: 45\n  X-RateLimit-Reset: 1699001200\n  X-RateLimit-Reset-After: 45\n  Retry-After: 45  (only when rate limited)\n```\n\n### Rate Limit Exceeded Response\n\n```json\n{\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Too many requests. Please retry after 45 seconds.\",\n    \"details\": {\n      \"limit\": 60,\n      \"window\": \"1 minute\",\n      \"retry_after\": 45\n    },\n    \"request_id\": \"req_xyz789\"\n  }\n}\n```\n\n### Implementation Strategy\n\n```python\n# Redis-based sliding window rate limiter\nimport redis\nimport time\nfrom functools import wraps\n\nclass RateLimiter:\n    def __init__(self, redis_client: redis.Redis):\n        self.redis = redis_client\n    \n    def check_rate_limit(\n        self,\n        key: str,\n        limit: int,\n        window_seconds: int\n    ) -> tuple[bool, dict]:\n        \"\"\"\n        Sliding window rate limiter\n        Returns: (allowed: bool, info: dict)\n        \"\"\"\n        now = time.time()\n        window_start = now - window_seconds\n        \n        pipe = self.redis.pipeline()\n        \n        # Remove old entries\n        pipe.zremrangebyscore(key, 0, window_start)\n        \n        # Count current requests\n        pipe.zcard(key)\n        \n        # Add current request\n        pipe.zadd(key, {str(now): now})\n        \n        # Set expiry\n        pipe.expire(key, window_seconds)\n        \n        results = pipe.execute()\n        current_count = results[1]\n        \n        remaining = max(0, limit - current_count - 1)\n        reset_time = int(now + window_seconds)\n        \n        info = {\n            \"limit\": limit,\n            \"remaining\": remaining,\n            \"reset\": reset_time,\n            \"reset_after\": window_seconds\n        }\n        \n        return current_count < limit, info\n\n# Middleware example\ndef rate_limit(limit: int, window: int):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(request, *args, **kwargs):\n            user_id = request.user.id if request.user else request.client.host\n            key = f\"ratelimit:{func.__name__}:{user_id}\"\n            \n            allowed, info = limiter.check_rate_limit(key, limit, window)\n            \n            # Add headers to response\n            response = await func(request, *args, **kwargs)\n            response.headers[\"X-RateLimit-Limit\"] = str(info[\"limit\"])\n            response.headers[\"X-RateLimit-Remaining\"] = str(info[\"remaining\"])\n            response.headers[\"X-RateLimit-Reset\"] = str(info[\"reset\"])\n            \n            if not allowed:\n                raise APIException(\n                    status_code=429,\n                    code=ErrorCode.RATE_LIMIT_EXCEEDED,\n                    message=f\"Rate limit exceeded. Retry after {info['reset_after']}s\"\n                )\n            \n            return response\n        return wrapper\n    return decorator\n```\n\n---\n\n## Authorization Matrix\n\n```yaml\nPermissions by Role:\n\nAdmin:\n  - task:* (all task operations)\n  - user:* (all user operations)\n  - comment:* (all comment operations)\n  - attachment:* (all attachment operations)\n\nManager:\n  - task:read, task:write, task:delete (own team)\n  - task:assign\n  - user:read\n  - comment:*, attachment:*\n\nUser:\n  - task:read (assigned or created)\n  - task:write (assigned or created)\n  - task:create\n  - comment:read, comment:write (own)\n  - attachment:read, attachment:write\n\nGuest (read-only):\n  - task:read (public tasks only)\n```\n\n---\n\n## Complete API Summary\n\n| Method | Endpoint | Description | Auth Required |\n|--------|----------|-------------|---------------|\n| POST | /auth/register | Register new user | No |\n| POST | /auth/login | Login | No |\n| POST | /auth/refresh | Refresh token | No |\n| POST | /auth/logout | Logout | Yes |\n| GET | /tasks | List tasks | Yes |\n| POST | /tasks | Create task | Yes |\n| GET | /tasks/{id} | Get task | Yes |\n| PUT | /tasks/{id} | Full update | Yes |\n| PATCH | /tasks/{id} | Partial update | Yes |\n| DELETE | /tasks/{id} | Delete task | Yes |\n| GET | /tasks/{id}/comments | List comments | Yes |\n| POST | /tasks/{id}/comments | Add comment | Yes |\n| PATCH | /tasks/{id}/comments/{id} | Update comment | Yes |\n| DELETE | /tasks/{id}/comments/{id} | Delete comment | Yes |\n| GET | /tasks/{id}/attachments | List attachments | Yes |\n| POST | /tasks/{id}/attachments | Upload file | Yes |\n| GET | /tasks/{id}/attachments/{id} | Get download URL | Yes |\n| DELETE | /tasks/{id}/attachments/{id} | Delete file | Yes |\n| GET | /users | List users | Yes |\n| GET | /users/me | Current user | Yes |",
    "tokens_in": 128,
    "tokens_out": 7198,
    "cost": 0.5417700000000001,
    "duration_ms": 68522,
    "success": true,
    "error": null
  },
  {
    "test_name": "Security Audit",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "Perform a security audit on this Node.js/Express code. Identify all security vulnerabilities, rate their severity (Critical/High/Medium/Low), and provide fixes:\n\n```javascript\n\nconst express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'admin123',\n  database: 'users'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  db.query(`SELECT * FROM users WHERE id = ${userId}`, (err, results) => {\n    res.json(results);\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  db.query(`SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`, (err, results) => {\n    if (results.length > 0) {\n      res.cookie('user', username);\n      res.json({ success: true, user: results[0] });\n    } else {\n      res.json({ success: false });\n    }\n  });\n});\n\napp.get('/file', (req, res) => {\n  const filename = req.query.name;\n  res.sendFile('/uploads/' + filename);\n});\n\napp.listen(3000);\n\n```",
    "response": "# Security Audit Report\n\n## Executive Summary\nThis code contains **8 critical to medium severity vulnerabilities** that could lead to complete database compromise, unauthorized access, and server exploitation.\n\n---\n\n## Vulnerabilities Identified\n\n### 1. SQL Injection (Critical) \ud83d\udd34\n**Location:** `/user` and `/login` endpoints\n**Risk:** Complete database compromise, data theft, authentication bypass\n\n```javascript\n// VULNERABLE CODE\ndb.query(`SELECT * FROM users WHERE id = ${userId}`, ...);\ndb.query(`SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`, ...);\n```\n\n**Attack Example:** `id=1; DROP TABLE users;--`\n\n**Fix:**\n```javascript\n// Use parameterized queries\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  db.query('SELECT * FROM users WHERE id = ?', [userId], (err, results) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(results);\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  db.query(\n    'SELECT * FROM users WHERE username = ? AND password = ?',\n    [username, password],\n    (err, results) => {\n      // ... handle results\n    }\n  );\n});\n```\n\n---\n\n### 2. Hardcoded Credentials (Critical) \ud83d\udd34\n**Location:** Database connection configuration\n**Risk:** Credential exposure in source control\n\n```javascript\n// VULNERABLE CODE\nconst db = mysql.createConnection({\n  password: 'admin123',\n});\n```\n\n**Fix:**\n```javascript\nrequire('dotenv').config();\n\nconst db = mysql.createConnection({\n  host: process.env.DB_HOST,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME\n});\n```\n\n---\n\n### 3. Plaintext Password Storage (Critical) \ud83d\udd34\n**Location:** `/login` endpoint\n**Risk:** Mass credential theft if database is compromised\n\n**Fix:**\n```javascript\nconst bcrypt = require('bcrypt');\n\n// Registration - hash password before storing\nconst hashedPassword = await bcrypt.hash(password, 12);\n\n// Login - compare hashed passwords\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  db.query('SELECT * FROM users WHERE username = ?', [username], async (err, results) => {\n    if (results.length > 0) {\n      const validPassword = await bcrypt.compare(password, results[0].password);\n      if (validPassword) {\n        // Generate secure session token instead\n      }\n    }\n  });\n});\n```\n\n---\n\n### 4. Path Traversal (High) \ud83d\udfe0\n**Location:** `/file` endpoint\n**Risk:** Arbitrary file read from server\n\n```javascript\n// VULNERABLE - allows: /file?name=../../../etc/passwd\nres.sendFile('/uploads/' + filename);\n```\n\n**Fix:**\n```javascript\nconst path = require('path');\n\napp.get('/file', (req, res) => {\n  const filename = req.query.name;\n  const safePath = path.join(__dirname, 'uploads', path.basename(filename));\n  \n  // Verify path is within uploads directory\n  if (!safePath.startsWith(path.join(__dirname, 'uploads'))) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  res.sendFile(safePath);\n});\n```\n\n---\n\n### 5. Missing Body Parser (High) \ud83d\udfe0\n**Location:** `/login` endpoint\n**Risk:** `req.body` is undefined, causing crashes\n\n**Fix:**\n```javascript\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n```\n\n---\n\n### 6. Insecure Cookie Configuration (Medium) \ud83d\udfe1\n**Location:** `/login` endpoint\n**Risk:** Session hijacking via XSS or network interception\n\n**Fix:**\n```javascript\nres.cookie('sessionId', secureToken, {\n  httpOnly: true,    // Prevents XSS access\n  secure: true,      // HTTPS only\n  sameSite: 'strict', // CSRF protection\n  maxAge: 3600000    // 1 hour expiry\n});\n```\n\n---\n\n### 7. No Error Handling (Medium) \ud83d\udfe1\n**Location:** All database queries\n**Risk:** Information leakage, application crashes\n\n**Fix:**\n```javascript\ndb.query('SELECT * FROM users WHERE id = ?', [userId], (err, results) => {\n  if (err) {\n    console.error('Database error:', err.message);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n  if (!results.length) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  res.json(results);\n});\n```\n\n---\n\n### 8. Missing Security Headers (Medium) \ud83d\udfe1\n**Risk:** XSS, clickjacking, MIME sniffing attacks\n\n**Fix:**\n```javascript\nconst helmet = require('helmet');\napp.use(helmet());\n```\n\n---\n\n## Complete Secured Code\n\n```javascript\nrequire('dotenv').config();\nconst express = require('express');\nconst mysql = require('mysql2');\nconst bcrypt = require('bcrypt');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst path = require('path');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use(limiter);\n\n// Secure database connection\nconst db = mysql.createConnection({\n  host: process.env.DB_HOST,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME\n});\n\napp.get('/user', (req, res) => {\n  const userId = parseInt(req.query.id, 10);\n  if (isNaN(userId)) {\n    return res.status(400).json({ error: 'Invalid user ID' });\n  }\n  \n  db.query('SELECT id, username, email FROM users WHERE id = ?', [userId], (err, results) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!results.length) return res.status(404).json({ error: 'User not found' });\n    res.json(results[0]);\n  });\n});\n\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  if (!username || !password) {\n    return res.status(400).json({ error: 'Missing credentials' });\n  }\n  \n  db.query('SELECT * FROM users WHERE username = ?', [username], async (err, results) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    if (results.length > 0 && await bcrypt.compare(password, results[0].password)) {\n      res.cookie('sessionId', generateSecureToken(), {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 3600000\n      });\n      res.json({ success: true });\n    } else {\n      res.status(401).json({ error: 'Invalid credentials' });\n    }\n  });\n});\n\napp.get('/file', (req, res) => {\n  const filename = path.basename(req.query.name || '');\n  const safePath = path.join(__dirname, 'uploads', filename);\n  \n  if (!safePath.startsWith(path.join(__dirname, 'uploads'))) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  res.sendFile(safePath);\n});\n\napp.listen(3000, () => console.log('Server running securely'));\n```\n\n---\n\n## Severity Summary\n\n| Severity | Count | Issues |\n|----------|-------|--------|\n| Critical | 3 | SQL Injection, Hardcoded Creds, Plaintext Passwords |\n| High | 2 | Path Traversal, Missing Body Parser |\n| Medium | 3 | Insecure Cookies, No Error Handling, Missing Headers |",
    "tokens_in": 359,
    "tokens_out": 2149,
    "cost": 0.16655999999999999,
    "duration_ms": 21249,
    "success": true,
    "error": null
  },
  {
    "test_name": "Architecture Decision",
    "framework": "anthropic-sdk-bedrock",
    "model": "us.anthropic.claude-opus-4-5-20251101-v1:0",
    "prompt": "A startup is building a real-time collaboration platform (like Google Docs) with these requirements:\n- Support 10,000 concurrent users per document\n- Sub-100ms latency for edits\n- Offline support with sync\n- Version history and conflict resolution\n- Multi-region deployment\n\nCompare and recommend architectures:\n1. WebSocket vs Server-Sent Events vs WebRTC\n2. CRDT vs Operational Transformation\n3. Database choice (PostgreSQL vs MongoDB vs custom)\n4. Message queue selection\n\nProvide a detailed recommendation with trade-offs.",
    "response": "# Real-Time Collaboration Platform Architecture Analysis\n\n## Executive Summary\n\nFor a Google Docs-like platform supporting 10,000 concurrent users per document with sub-100ms latency, I recommend:\n\n- **Transport**: WebSocket with WebRTC for P2P optimization\n- **Sync Algorithm**: CRDT (specifically Yjs)\n- **Database**: PostgreSQL + Redis + S3\n- **Message Queue**: Redis Streams with NATS for cross-region\n\n---\n\n## 1. Transport Protocol Comparison\n\n### WebSocket\n\n```javascript\n// WebSocket Server Implementation\nclass CollaborationWebSocketServer {\n  constructor() {\n    this.documents = new Map(); // docId -> Set of connections\n    this.connectionState = new Map(); // connection -> metadata\n  }\n\n  handleConnection(ws, request) {\n    const docId = this.extractDocId(request);\n    const userId = this.authenticateUser(request);\n    \n    // Register connection\n    if (!this.documents.has(docId)) {\n      this.documents.set(docId, new Set());\n    }\n    this.documents.get(docId).add(ws);\n    \n    this.connectionState.set(ws, {\n      docId,\n      userId,\n      lastActivity: Date.now(),\n      pendingAcks: new Map()\n    });\n\n    ws.on('message', (data) => this.handleMessage(ws, data));\n    ws.on('close', () => this.handleDisconnect(ws));\n    ws.on('error', (err) => this.handleError(ws, err));\n\n    // Send initial state\n    this.sendDocumentState(ws, docId);\n  }\n\n  async handleMessage(ws, rawData) {\n    const startTime = process.hrtime.bigint();\n    \n    try {\n      const message = JSON.parse(rawData);\n      \n      switch (message.type) {\n        case 'operation':\n          await this.handleOperation(ws, message);\n          break;\n        case 'cursor':\n          await this.handleCursorUpdate(ws, message);\n          break;\n        case 'presence':\n          await this.handlePresenceUpdate(ws, message);\n          break;\n        case 'ack':\n          this.handleAck(ws, message);\n          break;\n      }\n      \n      // Track latency\n      const endTime = process.hrtime.bigint();\n      const latencyMs = Number(endTime - startTime) / 1_000_000;\n      this.metrics.recordLatency('message_processing', latencyMs);\n      \n    } catch (error) {\n      this.sendError(ws, error);\n    }\n  }\n\n  async handleOperation(ws, message) {\n    const state = this.connectionState.get(ws);\n    const { docId, userId } = state;\n    \n    // Apply operation locally\n    const result = await this.applyOperation(docId, message.operation, userId);\n    \n    // Broadcast to all other clients in the document\n    const connections = this.documents.get(docId);\n    const broadcastMessage = JSON.stringify({\n      type: 'operation',\n      operation: result.transformedOperation,\n      userId,\n      timestamp: Date.now(),\n      version: result.version\n    });\n\n    for (const client of connections) {\n      if (client !== ws && client.readyState === WebSocket.OPEN) {\n        client.send(broadcastMessage);\n      }\n    }\n\n    // Acknowledge to sender\n    ws.send(JSON.stringify({\n      type: 'ack',\n      operationId: message.operationId,\n      version: result.version\n    }));\n  }\n\n  // Efficient broadcasting with batching\n  broadcastBatch(docId, operations) {\n    const connections = this.documents.get(docId);\n    if (!connections || connections.size === 0) return;\n\n    const batchMessage = JSON.stringify({\n      type: 'batch',\n      operations,\n      timestamp: Date.now()\n    });\n\n    // Use setImmediate for non-blocking broadcast\n    setImmediate(() => {\n      for (const client of connections) {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(batchMessage);\n        }\n      }\n    });\n  }\n}\n```\n\n### Server-Sent Events (SSE)\n\n```javascript\n// SSE Implementation for comparison\nclass SSECollaborationServer {\n  constructor() {\n    this.clients = new Map();\n  }\n\n  handleSSEConnection(req, res) {\n    const docId = req.params.docId;\n    const userId = req.user.id;\n\n    // SSE headers\n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'X-Accel-Buffering': 'no' // Disable nginx buffering\n    });\n\n    // Keep connection alive\n    const keepAlive = setInterval(() => {\n      res.write(': keepalive\\n\\n');\n    }, 15000);\n\n    const client = {\n      id: `${userId}-${Date.now()}`,\n      docId,\n      userId,\n      response: res,\n      keepAlive\n    };\n\n    this.addClient(docId, client);\n\n    req.on('close', () => {\n      clearInterval(keepAlive);\n      this.removeClient(docId, client);\n    });\n  }\n\n  sendEvent(client, eventType, data) {\n    const event = `event: ${eventType}\\ndata: ${JSON.stringify(data)}\\nid: ${Date.now()}\\n\\n`;\n    client.response.write(event);\n  }\n\n  // SSE requires separate endpoint for client->server communication\n  async handleOperationPost(req, res) {\n    const { docId, operation } = req.body;\n    const userId = req.user.id;\n\n    const result = await this.applyOperation(docId, operation, userId);\n    \n    // Broadcast via SSE\n    this.broadcastToDocument(docId, 'operation', {\n      operation: result.transformedOperation,\n      userId,\n      version: result.version\n    }, userId);\n\n    res.json({ success: true, version: result.version });\n  }\n}\n```\n\n### WebRTC for P2P Optimization\n\n```javascript\n// WebRTC P2P Layer for reducing server load\nclass WebRTCCollaborationLayer {\n  constructor(signalingServer) {\n    this.signalingServer = signalingServer;\n    this.peers = new Map();\n    this.localOperations = [];\n  }\n\n  async connectToPeer(peerId) {\n    const peerConnection = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { \n          urls: 'turn:turn.yourserver.com:443',\n          username: this.turnUsername,\n          credential: this.turnCredential\n        }\n      ]\n    });\n\n    // Create data channel for operations\n    const dataChannel = peerConnection.createDataChannel('operations', {\n      ordered: false, // Allow out-of-order for lower latency\n      maxRetransmits: 3\n    });\n\n    dataChannel.onopen = () => {\n      console.log(`P2P connection established with ${peerId}`);\n      this.peers.set(peerId, { connection: peerConnection, channel: dataChannel });\n    };\n\n    dataChannel.onmessage = (event) => {\n      this.handlePeerMessage(peerId, JSON.parse(event.data));\n    };\n\n    // Create and send offer\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    \n    this.signalingServer.send({\n      type: 'webrtc-offer',\n      targetPeerId: peerId,\n      offer: offer\n    });\n\n    return new Promise((resolve, reject) => {\n      peerConnection.oniceconnectionstatechange = () => {\n        if (peerConnection.iceConnectionState === 'connected') {\n          resolve(peerConnection);\n        } else if (peerConnection.iceConnectionState === 'failed') {\n          reject(new Error('ICE connection failed'));\n        }\n      };\n    });\n  }\n\n  broadcastOperation(operation) {\n    const message = JSON.stringify({\n      type: 'operation',\n      operation,\n      timestamp: Date.now()\n    });\n\n    // Send to all connected peers\n    for (const [peerId, { channel }] of this.peers) {\n      if (channel.readyState === 'open') {\n        channel.send(message);\n      }\n    }\n\n    // Also send to server for persistence and offline users\n    this.signalingServer.send({\n      type: 'operation',\n      operation\n    });\n  }\n}\n```\n\n### Transport Protocol Comparison Matrix\n\n| Criteria | WebSocket | SSE | WebRTC |\n|----------|-----------|-----|--------|\n| Bidirectional | \u2705 Native | \u274c Requires HTTP POST | \u2705 Native |\n| Latency | ~5-10ms | ~10-20ms | ~1-5ms (P2P) |\n| Connection overhead | Low | Medium | High (setup) |\n| Scalability | Good | Better (HTTP/2) | Excellent (P2P) |\n| Firewall friendly | Good | Excellent | Poor |\n| Offline reconnect | Manual | Auto (EventSource) | Manual |\n| Binary support | \u2705 | \u274c (text only) | \u2705 |\n| Browser support | 98%+ | 95%+ | 93%+ |\n\n**Recommendation**: Use WebSocket as primary with WebRTC mesh for high-activity documents (>100 concurrent editors).\n\n---\n\n## 2. CRDT vs Operational Transformation\n\n### CRDT Implementation (Yjs-based)\n\n```javascript\n// CRDT Implementation using Yjs concepts\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\nimport { IndexeddbPersistence } from 'y-indexeddb';\n\nclass CRDTDocumentManager {\n  constructor(docId, userId) {\n    this.docId = docId;\n    this.userId = userId;\n    \n    // Create Yjs document\n    this.ydoc = new Y.Doc();\n    this.ydoc.clientID = this.generateClientId(userId);\n    \n    // Document structure\n    this.content = this.ydoc.getText('content');\n    this.comments = this.ydoc.getArray('comments');\n    this.metadata = this.ydoc.getMap('metadata');\n    \n    // Awareness for cursors and presence\n    this.awareness = null;\n    \n    this.setupPersistence();\n    this.setupSync();\n  }\n\n  setupPersistence() {\n    // Local IndexedDB persistence for offline support\n    this.indexeddbProvider = new IndexeddbPersistence(this.docId, this.ydoc);\n    \n    this.indexeddbProvider.on('synced', () => {\n      console.log('Local content loaded from IndexedDB');\n    });\n  }\n\n  setupSync() {\n    // WebSocket sync provider\n    this.wsProvider = new WebsocketProvider(\n      'wss://collab.yourapp.com',\n      this.docId,\n      this.ydoc,\n      {\n        awareness: this.awareness,\n        resyncInterval: 5000,\n        maxBackoffTime: 10000\n      }\n    );\n\n    this.awareness = this.wsProvider.awareness;\n    \n    // Set local awareness state\n    this.awareness.setLocalState({\n      user: {\n        id: this.userId,\n        name: this.userName,\n        color: this.userColor\n      },\n      cursor: null,\n      selection: null\n    });\n\n    this.wsProvider.on('status', ({ status }) => {\n      console.log(`Connection status: ${status}`);\n      this.onConnectionStatusChange(status);\n    });\n\n    this.wsProvider.on('sync', (isSynced) => {\n      console.log(`Sync status: ${isSynced}`);\n      if (isSynced) {\n        this.onFullSync();\n      }\n    });\n  }\n\n  // Insert text at position\n  insert(index, text) {\n    this.ydoc.transact(() => {\n      this.content.insert(index, text);\n    }, this.userId);\n  }\n\n  // Delete text\n  delete(index, length) {\n    this.ydoc.transact(() => {\n      this.content.delete(index, length);\n    }, this.userId);\n  }\n\n  // Format text (rich text support)\n  format(index, length, attributes) {\n    this.ydoc.transact(() => {\n      // For rich text, use Y.XmlText or custom formatting\n      const formats = this.ydoc.getMap('formats');\n      const formatId = `${index}-${length}-${Date.now()}`;\n      formats.set(formatId, {\n        index,\n        length,\n        attributes,\n        timestamp: Date.now()\n      });\n    }, this.userId);\n  }\n\n  // Update cursor position\n  updateCursor(anchor, head) {\n    this.awareness.setLocalStateField('cursor', {\n      anchor: Y.createRelativePositionFromTypeIndex(this.content, anchor),\n      head: Y.createRelativePositionFromTypeIndex(this.content, head)\n    });\n  }\n\n  // Get all remote cursors\n  getRemoteCursors() {\n    const cursors = [];\n    this.awareness.getStates().forEach((state, clientId) => {\n      if (clientId !== this.ydoc.clientID && state.cursor) {\n        const anchor = Y.createAbsolutePositionFromRelativePosition(\n          state.cursor.anchor,\n          this.ydoc\n        );\n        const head = Y.createAbsolutePositionFromRelativePosition(\n          state.cursor.head,\n          this.ydoc\n        );\n        \n        if (anchor && head) {\n          cursors.push({\n            clientId,\n            user: state.user,\n            anchor: anchor.index,\n            head: head.index\n          });\n        }\n      }\n    });\n    return cursors;\n  }\n\n  // Version history using Y.js snapshots\n  createSnapshot() {\n    return Y.snapshot(this.ydoc);\n  }\n\n  restoreSnapshot(snapshot) {\n    const restoredDoc = Y.createDocFromSnapshot(this.ydoc, snapshot);\n    return restoredDoc.getText('content').toString();\n  }\n\n  // Get document state for persistence\n  getEncodedState() {\n    return Y.encodeStateAsUpdate(this.ydoc);\n  }\n\n  // Apply state from server\n  applyEncodedState(update) {\n    Y.applyUpdate(this.ydoc, update);\n  }\n\n  // Merge states from multiple sources\n  mergeStates(states) {\n    const mergedUpdate = Y.mergeUpdates(states);\n    Y.applyUpdate(this.ydoc, mergedUpdate);\n  }\n\n  // Offline queue management\n  getLocalPendingUpdates() {\n    return Y.encodeStateAsUpdate(\n      this.ydoc,\n      Y.encodeStateVector(this.ydoc) // Only local changes\n    );\n  }\n}\n```\n\n### Operational Transformation Implementation\n\n```javascript\n// OT Implementation for comparison\nclass OTDocumentManager {\n  constructor(docId, userId) {\n    this.docId = docId;\n    this.userId = userId;\n    this.content = '';\n    this.revision = 0;\n    this.pendingOperations = [];\n    this.sentOperations = [];\n    this.serverAcknowledged = 0;\n  }\n\n  // OT operation types\n  createInsertOp(position, text) {\n    return {\n      type: 'insert',\n      position,\n      text,\n      userId: this.userId,\n      revision: this.revision\n    };\n  }\n\n  createDeleteOp(position, length) {\n    return {\n      type: 'delete',\n      position,\n      length,\n      userId: this.userId,\n      revision: this.revision\n    };\n  }\n\n  // Transform two operations\n  transform(op1, op2) {\n    if (op1.type === 'insert' && op2.type === 'insert') {\n      return this.transformInsertInsert(op1, op2);\n    } else if (op1.type === 'insert' && op2.type === 'delete') {\n      return this.transformInsertDelete(op1, op2);\n    } else if (op1.type === 'delete' && op2.type === 'insert') {\n      return this.transformDeleteInsert(op1, op2);\n    } else if (op1.type === 'delete' && op2.type === 'delete') {\n      return this.transformDeleteDelete(op1, op2);\n    }\n  }\n\n  transformInsertInsert(op1, op2) {\n    // op1 is the operation to transform, op2 is the context\n    const newOp1 = { ...op1 };\n    \n    if (op1.position < op2.position) {\n      // op1 is before op2, no change needed\n      return newOp1;\n    } else if (op1.position > op2.position) {\n      // op1 is after op2, shift position\n      newOp1.position += op2.text.length;\n      return newOp1;\n    } else {\n      // Same position, use userId for tiebreaker\n      if (op1.userId < op2.userId) {\n        return newOp1;\n      } else {\n        newOp1.position += op2.text.length;\n        return newOp1;\n      }\n    }\n  }\n\n  transformInsertDelete(op1, op2) {\n    const newOp1 = { ...op1 };\n    \n    if (op1.position <= op2.position) {\n      return newOp1;\n    } else if (op1.position >= op2.position + op2.length) {\n      newOp1.position -= op2.length;\n      return newOp1;\n    } else {\n      // Insert position is within deleted range\n      newOp1.position = op2.position;\n      return newOp1;\n    }\n  }\n\n  transformDeleteInsert(op1, op2) {\n    const newOp1 = { ...op1 };\n    \n    if (op2.position >= op1.position + op1.length) {\n      return newOp1;\n    } else if (op2.position <= op1.position) {\n      newOp1.position += op2.text.length;\n      return newOp1;\n    } else {\n      // Insert is within delete range - split delete\n      return {\n        type: 'compound',\n        operations: [\n          {\n            type: 'delete',\n            position: op1.position,\n            length: op2.position - op1.position\n          },\n          {\n            type: 'delete',\n            position: op2.position + op2.text.length,\n            length: op1.length - (op2.position - op1.position)\n          }\n        ]\n      };\n    }\n  }\n\n  transformDeleteDelete(op1, op2) {\n    const newOp1 = { ...op1 };\n    \n    if (op1.position >= op2.position + op2.length) {\n      newOp1.position -= op2.length;\n      return newOp1;\n    } else if (op1.position + op1.length <= op2.position) {\n      return newOp1;\n    } else {\n      // Overlapping deletes\n      const start1 = op1.position;\n      const end1 = op1.position + op1.length;\n      const start2 = op2.position;\n      const end2 = op2.position + op2.length;\n\n      if (start1 >= start2 && end1 <= end2) {\n        // op1 is fully contained in op2\n        return { type: 'noop' };\n      } else if (start2 >= start1 && end2 <= end1) {\n        // op2 is fully contained in op1\n        newOp1.length -= op2.length;\n        return newOp1;\n      } else if (start1 < start2) {\n        newOp1.length = start2 - start1;\n        return newOp1;\n      } else {\n        newOp1.position = start2;\n        newOp1.length = end1 - end2;\n        return newOp1;\n      }\n    }\n  }\n\n  // Client-side operation handling\n  applyLocalOperation(op) {\n    // Apply to local content immediately\n    this.applyToContent(op);\n    \n    // Add to pending queue\n    this.pendingOperations.push(op);\n    \n    // If no operations in flight, send immediately\n    if (this.sentOperations.length === 0) {\n      this.sendNextOperation();\n    }\n  }\n\n  sendNextOperation() {\n    if (this.pendingOperations.length === 0) return;\n    \n    const op = this.pendingOperations.shift();\n    this.sentOperations.push(op);\n    \n    this.sendToServer({\n      type: 'operation',\n      operation: op,\n      revision: this.serverAcknowledged\n    });\n  }\n\n  handleServerAck(ackRevision) {\n    this.serverAcknowledged = ackRevision;\n    this.sentOperations.shift();\n    this.revision = ackRevision;\n    \n    // Send next pending operation\n    this.sendNextOperation();\n  }\n\n  handleRemoteOperation(remoteOp) {\n    // Transform against all pending and sent operations\n    let transformedOp = remoteOp;\n    \n    for (const sentOp of this.sentOperations) {\n      transformedOp = this.transform(transformedOp, sentOp);\n    }\n    \n    for (const pendingOp of this.pendingOperations) {\n      const [newTransformed, newPending] = this.transformPair(transformedOp, pendingOp);\n      transformedOp = newTransformed;\n      // Update pending operation in place\n      Object.assign(pendingOp, newPending);\n    }\n    \n    // Apply transformed operation\n    this.applyToContent(transformedOp);\n    this.revision++;\n  }\n\n  applyToContent(op) {\n    if (op.type === 'insert') {\n      this.content = \n        this.content.slice(0, op.position) + \n        op.text + \n        this.content.slice(op.position);\n    } else if (op.type === 'delete') {\n      this.content = \n        this.content.slice(0, op.position) + \n        this.content.slice(op.position + op.length);\n    }\n  }\n}\n```\n\n### CRDT vs OT Comparison\n\n| Criteria | CRDT | OT |\n|----------|------|-----|\n| Complexity | Lower | Higher |\n| Server requirements | Stateless possible | Stateful required |\n| Conflict resolution | Automatic | Manual transformation |\n| Memory overhead | Higher | Lower |\n| Network overhead | Higher (state vectors) | Lower (operations) |\n| Offline support | Excellent | Complex |\n| Consistency model | Eventual | Immediate |\n| Undo/Redo | Complex | Straightforward |\n| Production ready | Yjs, Automerge | Google Docs, ShareDB |\n\n**Recommendation**: CRDT (Yjs) for better offline support and simpler server architecture.\n\n---\n\n## 3. Database Architecture\n\n### PostgreSQL + Redis + S3 Hybrid\n\n```sql\n-- PostgreSQL Schema for Document Management\n\n-- Documents metadata\nCREATE TABLE documents (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(500) NOT NULL,\n    owner_id UUID NOT NULL REFERENCES users(id),\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    deleted_at TIMESTAMPTZ,\n    \n    -- Document settings\n    settings JSONB DEFAULT '{}',\n    \n    -- Access control\n    visibility VARCHAR(20) DEFAULT 'private',\n    \n    -- CRDT state reference (stored in S3)\n    current_state_key VARCHAR(500),\n    current_state_version BIGINT DEFAULT 0,\n    \n    -- Full-text search\n    search_vector TSVECTOR\n);\n\nCREATE INDEX idx_documents_owner ON documents(owner_id);\nCREATE INDEX idx_documents_search ON documents USING GIN(search_vector);\nCREATE INDEX idx_documents_updated ON documents(updated_at DESC);\n\n-- Document versions (snapshots)\nCREATE TABLE document_versions (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    document_id UUID NOT NULL REFERENCES documents(id),\n    version_number BIGINT NOT NULL,\n    \n    -- S3 reference for full state\n    state_key VARCHAR(500) NOT NULL,\n    state_size_bytes BIGINT,\n    \n    -- Metadata\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    created_by UUID REFERENCES users(id),\n    \n    -- Optional: inline delta from previous version\n    delta_from_version BIGINT,\n    delta_data BYTEA,\n    \n    UNIQUE(document_id, version_number)\n);\n\nCREATE INDEX idx_versions_document ON document_versions(document_id, version_number DESC);\n\n-- Document access/permissions\nCREATE TABLE document_permissions (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    document_id UUID NOT NULL REFERENCES documents(id),\n    user_id UUID REFERENCES users(id),\n    email VARCHAR(255), -- For pending invites\n    \n    permission_level VARCHAR(20) NOT NULL, -- 'view', 'comment', 'edit', 'admin'\n    \n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    created_by UUID REFERENCES users(id),\n    \n    UNIQUE(document_id, user_id),\n    UNIQUE(document_id, email)\n);\n\nCREATE INDEX idx_permissions_user ON document_permissions(user_id);\nCREATE INDEX idx_permissions_document ON document_permissions(document_id);\n\n-- Comments\nCREATE TABLE comments (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    document_id UUID NOT NULL REFERENCES documents(id),\n    parent_id UUID REFERENCES comments(id),\n    \n    -- Position reference (CRDT-compatible)\n    anchor_data JSONB NOT NULL, -- Relative position in CRDT\n    \n    content TEXT NOT NULL,\n    resolved BOOLEAN DEFAULT FALSE,\n    \n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    created_by UUID NOT NULL REFERENCES users(id),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_comments_document ON comments(document_id);\nCREATE INDEX idx_comments_parent ON comments(parent_id);\n\n-- Operation log for debugging and analytics\nCREATE TABLE operation_log (\n    id BIGSERIAL PRIMARY KEY,\n    document_id UUID NOT NULL,\n    user_id UUID NOT NULL,\n    \n    operation_type VARCHAR(50),\n    operation_data JSONB,\n    \n    client_timestamp TIMESTAMPTZ,\n    server_timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    -- Partitioning support\n    created_date DATE DEFAULT CURRENT_DATE\n) PARTITION BY RANGE (created_date);\n\n-- Create partitions for operation log\nCREATE TABLE operation_log_2024_01 PARTITION OF operation_log\n    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');\n```\n\n```javascript\n// Database Access Layer\nclass DocumentRepository {\n  constructor(pgPool, redisClient, s3Client) {\n    this.pg = pgPool;\n    this.redis = redisClient;\n    this.s3 = s3Client;\n    this.bucket = 'collaboration-states';\n  }\n\n  // Get document with caching\n  async getDocument(docId) {\n    // Try cache first\n    const cached = await this.redis.get(`doc:${docId}`);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    // Fetch from PostgreSQL\n    const result = await this.pg.query(`\n      SELECT d.*, \n             array_agg(DISTINCT dp.user_id) as collaborators\n      FROM documents d\n      LEFT JOIN document_permissions dp ON d.id = dp.document_id\n      WHERE d.id = $1 AND d.deleted_at IS NULL\n      GROUP BY d.id\n    `, [docId]);\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const doc = result.rows[0];\n    \n    // Cache for 5 minutes\n    await this.redis.setex(`doc:${docId}`, 300, JSON.stringify(doc));\n    \n    return doc;\n  }\n\n  // Get CRDT state\n  async getDocumentState(docId) {\n    // Check Redis for hot state\n    const hotState = await this.redis.getBuffer(`state:${docId}`);\n    if (hotState) {\n      return hotState;\n    }\n\n    // Fetch from S3\n    const doc = await this.getDocument(docId);\n    if (!doc?.current_state_key) {\n      return null;\n    }\n\n    const s3Response = await this.s3.getObject({\n      Bucket: this.bucket,\n      Key: doc.current_state_key\n    }).promise();\n\n    const state = s3Response.Body;\n    \n    // Cache in Redis (with compression for large states)\n    if (state.length < 1024 * 1024) { // < 1MB\n      await this.redis.setex(`state:${docId}`, 60, state);\n    }\n\n    return state;\n  }\n\n  // Save CRDT state\n  async saveDocumentState(docId, state, userId) {\n    const version = Date.now();\n    const stateKey = `documents/${docId}/states/${version}`;\n    \n    // Upload to S3\n    await this.s3.putObject({\n      Bucket: this.bucket,\n      Key: stateKey,\n      Body: state,\n      ContentType: 'application/octet-stream',\n      Metadata: {\n        'document-id': docId,\n        'version': version.toString(),\n        'user-id': userId\n      }\n    }).promise();\n\n    // Update PostgreSQL\n    await this.pg.query(`\n      UPDATE documents \n      SET current_state_key = $2,\n          current_state_version = $3,\n          updated_at = NOW()\n      WHERE id = $1\n    `, [docId, stateKey, version]);\n\n    // Create version record\n    await this.pg.query(`\n      INSERT INTO document_versions (document_id, version_number, state_key, state_size_bytes, created_by)\n      VALUES ($1, $2, $3, $4, $5)\n    `, [docId, version, stateKey, state.length, userId]);\n\n    // Update Redis cache\n    await this.redis.setex(`state:${docId}`, 60, state);\n    await this.redis.del(`doc:${docId}`);\n\n    return { version, stateKey };\n  }\n\n  // Get version history\n  async getVersionHistory(docId, limit = 50, beforeVersion = null) {\n    let query = `\n      SELECT v.*, u.name as created_by_name\n      FROM document_versions v\n      LEFT JOIN users u ON v.created_by = u.id\n      WHERE v.document_id = $1\n    `;\n    \n    const params = [docId];\n    \n    if (beforeVersion) {\n      query += ` AND v.version_number < $2`;\n      params.push(beforeVersion);\n    }\n    \n    query += ` ORDER BY v.version_number DESC LIMIT $${params.length + 1}`;\n    params.push(limit);\n\n    const result = await this.pg.query(query, params);\n    return result.rows;\n  }\n\n  // Restore version\n  async restoreVersion(docId, versionNumber, userId) {\n    // Get the version's state\n    const versionResult = await this.pg.query(`\n      SELECT state_key FROM document_versions\n      WHERE document_id = $1 AND version_number = $2\n    `, [docId, versionNumber]);\n\n    if (versionResult.rows.length === 0) {\n      throw new Error('Version not found');\n    }\n\n    const s3Response = await this.s3.getObject({\n      Bucket: this.bucket,",
    "tokens_in": 146,
    "tokens_out": 8192,
    "cost": 0.61659,
    "duration_ms": 86872,
    "success": true,
    "error": null
  }
]